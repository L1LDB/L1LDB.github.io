---
title: "🐢 chap12. 최신 C"
author: gani0325
date: 2023-12-31 20:00:00 +09:00
categories: [전문가를 위한 C, "chap12. 최신 C"]
tags: [전문가를 위한 C, C언어, 11주차, 이가은]
render_with_liquid: false
math: true
---

<h2> ⭐ 12.1 C11 </h2>

- C 언어는 ISO 표준으로 표준화 되었음
  - C 를 개선하고 새로운 기능을 도입함
- C99 < C11 (이전의 C99 표준 개선) < C18 (C11 대체)
  - C18은 새로운 기능 제공 X, C11 에서 발견된 문제를 수정했을 뿐!

<aside>

    💡 C 언어는 꾸준히 개선되고 있음

    - C 버전을 감지하는 방법 & 여러 C 버전에 호환하는 C 코드 작성
    - 변환값이 없는 함수와 경계 검사 함수와 같은, 최적화되고 안전한 코드 작성하는 새로운 기능
    - 새로운 자료형과 메모리 정렬 기술
    - 타입 제네릭 함수
    - 이전 표준에는 포함되지 않았던 C11의 유니코드 지원
    - 익명 구조체와 공용체
    - C11의 멀티 스레딩 및 동기화 기술에 대한 표준 지원

</aside>

- 새로운 기능을 도입하려면 이전 코드나 기능을 그대로 유지하면서 수행
  - **기존 프로그램에 새로운 문제를 일으키면 안되고, 버그가 없어야 함**
  - C11 만들기 전 C 커뮤니티 사람들의 [염려한 걱정과 생각 자료](https://www.open-std.org/JTC1/SC22/wg14/www/docs/n1250.pdf)
  - But, C11 출시되었을 때 이상적인 형태가 아니었으며 실제로 심각한 결함 있었음
  - C18 은 C11 에서 발견된 결함을 고치고자 함 (비공식적으로 C17)
  - 암튼, 표준 정리하는 과정이 굉장히 어렵고 까다로움 😫

<h2> ⭐ 12.2 C 표준 지원 버전 찾기 </h2>

- C11 호환 가능한 컴파일러 : gcc, clang 같은 오픈 소스 컴파일
- So, 특정 매크로를 사용해 C 버전을 감지하고, 버전에 따라서 지원되는 기능을 사용하는 법 알아보자 ❗

  1. 먼저 현재 어떤 버전을 사용하는지 확인하기

     1. 리눅스에서는 gcc, macOS 에서는 clang 사용
     2. 현재 C 표준 버전을 감지하기 위해 기존에 정의된 매크로를 런타임 시 어떻게 사용하는가

     - C 표준 버전을 **감지**하기 & **컴파일** 하기

       - C 표준의 여러 버전 구별할 수 있음

       ```c
       #include <stdio.h>

       int main(int argc, char** argv) {
       // 제일 최신
       #if __STDC_VERSION__ >= 201710L
        printf("Hello World from C18!\n");
       #elif __STDC_VERSION__ >= 201112L
        printf("Hello World from C11!\n");
       #elif __STDC_VERSION__ >= 199901L
        printf("Hello World from C99!\n");

       // 제일 옛날
       #else
        printf("Hello World from C89/C90!\n");
       #endif
        return 0;
       }
       ```

       - 다양한 버전의 C 표준으로 컴파일하기

         - 컴파일러로 **-std=CXX** 옵션을 전달해야 함
         - 최신 컴파일러의 기본 C 표준 버전은 C11 임

         ```bash
         $ gcc ExtremeC_examples_chapter12_1.c -o ex12_1.out
         $ ./ex12_1.out
         Hello World from C11!

         $ gcc ExtremeC_examples_chapter12_1.c -o ex12_1.out -std=c11
         $ ./ex12_1.out
         Hello World from C11!

         $ gcc ExtremeC_examples_chapter12_1.c -o ex12_1.out -std=c99
         $ ./ex12_1.out
         Hello World from C99!

         $ gcc ExtremeC_examples_chapter12_1.c -o ex12_1.out -std=c90
         $ ./ex12_1.out
         Hello World from C89/C90!

         $ gcc ExtremeC_examples_chapter12_1.c -o ex12_1.out -std=c89
         $ ./ex12_1.out
         Hello World from C89/C90!
         ```

<h2> ⭐ 12.3 gets 함수의 제거 </h2>

- 유명한 gets 함수가 제거됨
  - C11 표준에서 gets 쓰면 C11 컴파일러로 컴파일 되지 않음
  - **gets 함수**
    - 키보드로부터 문자열을 입력받아 버퍼에 저장하는 함수
      - 이 함수는 **하나의 인자**를 요구하는데, 그것은 **입력받은 값을 저장할 버퍼**
      - ❓ **버퍼**란
        - buffer 배열 변수의 시작 주소
          - C언어에서 “배열의 이름은 그 배열의 시작 주소와 동일하다”
          - gets() 함수의 인자로 전달되는 것은 **“메모리 주소” 값** (buffer 변수의 시작 주소)
          - 엔터가 입력 될 때까지 입력을 받음
            - 사용자가 엔터를 치기 전까지 입력한 값들을 인자로 주어진 메모리 주소에 저장한다❗
            - So,, 엔터 입력 전까지 많은 값 입력.. ⇒ 사용자의 과도한 입력이 결국 🚨 **버퍼 오버 플로우**를 발생
    - **버퍼 오버플로** 공격의 대상이 된다
    - 경계 검사가 없고 호출 프로그램이 다음에 올 행의 길이를 확실하게 결정하지 못하는 만큼, 이 함수는 악성 사용자가 버퍼 오버플로 공격을 통해 실행 중인 프로그램의 기능을 임의로 변경할 수 있음
  - 반면에 **fgets** 함수는 경계 검사 됨
    - **fgets 함수**
      - **FILE 구조체**를 사용하여 **파일 입출력 스트림**에서 **문자열**을 가져오는 함수
        ```arduino
        char*fgets(char* str,int numChars, FILE* stream);
        char*fgets(char* str,int numChars, stdin);   // 키보드로도 입력 가능
        ```
        1. 첫 번째 매개변수(str) : 파일에서 읽은 문자열을 저장할 **메모리의 주소**를 넘겨주기
        2. 두 번째 매개변수(numChars) : 저장할 문자의 **최대 개수**를 지정
        3. 세 번째 매개변수(stream) : 파일에서 문자열을 읽기 위해 사용할 **파일 포인터**
           - FILE 구조체 사용하며, 텍스트 파일 관리하는 포인터
        4. 결과를 string에 저장하고 스트링 끝에 널(null) 문자(\0)를 추가

<h2> ⭐ 12.4 fopen 함수로의 변화 </h2>

- **fopen 함수**

  - 파일을 열어서 파일 서술자(descriptor) 를 그 파일로 반환할 때 사용
  - 파일 ! 꼭 파일 시스템의 어떤 파일이 아님,, 굉장히 보편적이다
  - fopen 함수 패밀리에 대한 다양한 시그니처

    ```c
    FILE* fopen(const char *pathname, const char *mode);
    FILE* fdopen(int fd, const char *mode);
    FILE* freopen(const char *pathname, const char *mode, FILE
    *stream);
    ```

    - 모든 시그니처는 mode 입력을 받음

      - **mode** : 파일을 여는 방법을 정하는 문자열

    - FreeBSD 매뉴얼의 fopen 함수

      - **모드 x** 는 C11 에서 도입됨

        - 파일을 쓰기 위해 열려면 fopen 에 모드 w 또는 w+ 넣기
          - 이미 파일이 존재한다면,, w 또는 w+ 모드는 파일을 삭제함 (비움)
          - So, 파일 추가하면서 현재 내용 유지하려면 a 모드 사용하기

        ```bash
        $ man 3 fopen
        ...
        mode 인수는 다음 문자 중 하나로 시작하는 문자열을 가리킵니다.

        	"r" 읽기 모드로 파일을 엽니다. 스트림은 파일의 가장 앞에 위치합니다.
        파일이 존재하지 않는 경우 실패합니다.
        	"w" 쓰기 모드로 파일을 엽니다. 스트림은 파일의 가장 앞에 위치합니다.
        파일이 존재하지 않는 경우 파일을 생성합니다.
        	"a" 쓰기 모드로 파일을 엽니다. 스트림은 파일의 가장 끝에 위치합니다.
        fseek(3) 이나 이와 유사한 것과 상관없이,
        항상 파일의 현재 끝부분에서 파일 이어 쓰기가 끝납니다.
        파일이 존재하지 않는 경우 파일을 생성합니다.

        "r", "w", "a" 뒤에 "+"을 옵션으로 추가하면 **읽기 및 쓰기 모드**로 파일을 엽니다.
        파일이 이미 존재하는 경우 "w" 다음 "x"를 옵션으로 추가하거나,
        "w+"을 사용하면 fopen()이 호출됩니다.

        위에 추가로 "" 옵션을 추가하면 fopen()을 호출해
        기본 파일 서술자에 FD_CLOEXEC 플래그를 설정합니다.

        모드 문자열은 "+"이나 첫 번째 글자 다음에 "b"를 포함할 수 있습니다
        ```

  - 파일이 존재하는지 확인할 때, 파일 시스템 API 사용하지 않으면서 파일 열기 위한 상용구 더 적게 쓸 수 있음
  - 그밖에도, fopen_s API의 도입이 있음 (안전한 fopen 역할 버전 → 버퍼의 결함 감지하기 위해, 제공된 버퍼와 그 경계에 대한 추가 검사 수행)

<h2> ⭐ 12.5 경계 검사 함수 </h2>

- 문자열과 바이트 배열에서 작동하는 C 프로그램의 심각한 문제는..
  - 🚨 버퍼나 바이트 배열의 경계로 쉽게 넘어갈 수 있음
    - **버퍼** : 바이트 배열이나 문자열 변수의 자리 표시자로 사용되는 메모리 영역
    - 버퍼의 경계를 넘어가면 → **버퍼 오버플로** 발생
    - 이를 통해 악성 개체가 공격 → **버퍼 오버플로 공격**
    - 이런 유형의 공격 → 서비스 거부 (DOS) 발생, 악용
  - strcpy, strcat 같은 string.h 에 있는 문자열 조작 함수는 버퍼 오버플로 공격 방지의 경계 검사 메커니즘이 부족함
- But, C11 에서 새로운 함수가 도입됨
  - **경계 검사 함수** : 문자열 조작 함수에서 이름 빌려옴, 끝에 **\_s** 붙음
    - **\_s 접미사** : **취약점을 종료**하기 위해 **런타임 검사를 더 많이 수행**하는 함수를 안전한 버전이라고 구분함
      ```c
      errno_t strcpy_s(char *restrict dest, rsize_t destsz, const char
      *restrict src);
      ```
      - 첫 번째 인수 : 복사할 문자열 (다른 변수, 메모리)
      - 두 번째 인수 : dest 버퍼의 길이
        - 함수는 할당되지 않은 메모리에 쓰지 않도록 dest 버퍼의 크기보다 src 문자열이 짧거나 같은지 확인 등 런타임 검사 수행함
        - 복사될 메모리의 크기를 적어야 함!
      - 세 번째 인수 : 원본 문자열

<h2> ⭐ 12.6 값을 반환하지 않는 함수 </h2>

- 함수 호출은 return 키워드를 사용하거나 함수의 블록 끝에 도달하면 종료
- 호출이 절대 끝나지 않을 때도 있는데, 보통은 어떤 의도를 가지고 일부러 수행함
- 값을 반환하지 않는 함수

  ```c
  void main_loop() {
   while (1) {
   ...
   }
  }

  int main(int argc, char** argv) {
   ...
   main_loop();
   return 0;
  }
  ```

  - main_loop() 함수는 프로그램의 주요 작업 수행하고 함수에서 돌아오면 프로그램이 종료됨
    - 이런 경우에 컴파일러는 최적화 더 많이 수행함
  - But, main_loop() 는 어떻게든 절대 변환되지 않음
  - C11 에서는 **값을 반환하지 않는 함수라고 표시**되는 기능이 있음
    - stdnoreturn.h 헤더 파일의 **\_Noreturn** 키워드를 사용해 절대 종료되지 않는 함수 지정함
    - main_loop 를 끝나지 않는 함수로 표시하는 \_Noreturn 키워드 사용하기
      ```c
      _Noreturn void main_loop() {
       while (true) {
       ...
       }
      }
      ```
      - 프로그램의 빠른 종료를 위해 C11 에서 최근에 추가됨
        - exit, quick_exit, abort → 값을 반환하지 않는 함수로 간주함
      - 반환값이 없는 함수의 존재를 컴파일러가 알고 있다면❗ 의도치 않게 반환값이 없는 함수 호출을 인식할 수 있음 → 논리적 버그에 대한 신호 → 적절하게 경고함 🚨
      - But, \_Noreturn 으로 표시한 함수가 반환값이 있다면 정의되지 않은 행위 → 권장 X

<h2> ⭐ 12.7 타입 제네릭 매크로 </h2>

- C11 에서 **\_Generic** 이라는 새 키워드 도입

  - **컴파일 하는 동안 자료형을 인식하는 매크로를 작성하는데 사용**함
  - 인수의 자료형에 따라 값을 변경할 수 있는 매크로를 작성할 수 있음 → **일반 (Generic) 선택**

    - 제너릭 매크로의 예

      ```c
      #include <stdio.h>

      #define abs(x) _Generic((x), int: absi, double: absd)(x)

      int absi(int a) {
       return a > 0 ? a : -a;
      }

      double absd(double a) {
       return a > 0 ? a : -a;
      }

      int main(int argc, char** argv) {
       // C에서 오버로딩 대체용 -> 타입 제너릭 매크로
       printf("abs(-2): %d\n", abs(-2));
       printf("abs(2.5): %f\n", abs(2.5));
       return 0;
      }

      // abs(-2): 2
      // abs(2.5): 2.500000
      ```

      - x 인수의 자료형에 따라 다른 표현을 사용함
        - **정수값**이면 **absi**
        - **double 값**이라면 **absd**
      - C11 의 새로운 기능이 아니었고 이전에도 볼 수 있었으나 C 표준에 안속했음 (지금은 표준이 되었음)
        **⇒ So, 자료형을 인식하는 매크로 작성이 가능**

<h2> ⭐ 12.8 유니코드 </h2>

- C11 표준에 추가된 중요한 기능 중 하나 UTF-8, UTF-16, UTF-32 인코딩을 통한 유니코드 지원
- C11 이전에는 IBM 유니코드 국제 컴포넌트 (ICU)와 같은 서드 파티 라이브러리를 사용함
- 아스키와 아스키 확장 문자를 저장하는 8비트 변수인 char와 unsigned char 형만 있었습니다.
  - 확장문자: 255 이후에 해당하는 숫잣값을 저장하기 위해 1바이트 이상을 더 사용하는 문자.
- UTF-8 UTF-16은 가변 길이 인코딩이라고 합니다.
  - 문자 당 1바이트 미만을 사용하는 초기 가변 길이 인코딩은 종종 초기 마이크로컴퓨터용 어드벤처 게임에서 영어 텍스트를 더 적은 바이트로 패킹(pack)하기 위해 사용됨
- UTF-8은 아스키의 상위 집합으로 봅니다. 이는 아스키 문자(확장 아스키 문자는 아닙니다.)와 표현이 같기 때문입니다.
  - UTF-16은 모든 문자를 저장하기 위해 하나 또는 2개의 워드를 사용합니다.(각 워드는 16비트를 갖습니다
  - 사용하는 32비트 CPU(ARM 등)라면 워드는 32비트가 된다
- UTF-32는 모든 문자에 대한 값을 저장하기 위해 정확히 4바이트로 고정 크기 인코딩입니다.
- UTF-8와 UTF-16은 자주 나오는 문자에 더 작은 바이트를 사용해야 하는 응용프로그램에 적합합니다.
- UTF-32은 UTF-8와 UTF-16에 비해 더 많은 메모리 공간을 소비합니다. 하지만 UTF-8와 UTF-16은 압축 인코딩이라서 더 많은 연산을 해야합니다.

<h2> ⭐ 12.9 익명 구조체와 익명 공용체 </h2>

- 익명 구조체와 익명 공용체는 이름을 갖지 않는 자료형 정의로, 보통 다른 자료형 내에서 중첩 자료형으로 사용됩니다.

```c
typedef struct {
  union {
    struct {
      int x;
      int y;
    };
    int data[2];
  };
} point_t;
```

- union과 struct의 이름이 없는 것을 알 수 있습니다.

```c
/* File name: ExtremeC_examples_chapter12_4.c
 * Description: Anonymous structures and unions
 */

#include <stdio.h>

typedef struct {
  union {
    struct {
      int x;
      int y;
    };
    int data[2];
  };
} point_t;

int main(int argc, char** argv) {
  point_t p;
  p.x = 10;
  p.data[1] = -5;
  printf("Point (%d, %d) using anonymous structure.\n", p.x, p.y);
  printf("Point (%d, %d) using anonymous byte array.\n",
      p.data[0], p.data[1]);
  return 0;
}
```

<h2> ⭐ 12.10 멀티스레딩 </h2>

- C에서 멀티 스레딩은 POSIX 스레딩 함수 또는 pthread 라이브러리를 통해 오랫동안 지원이 되었습니다.
- POSIX 스레딩 라이브러리는 이름 그대로 리눅스나 유닉스 계열 시스템과 같은 POSIX호환 시스템에서만 사용할 수 있습니다.
- 윈도우와 같이 POSIX 호환 시스템이 아닐 경우 운영체제가 제공하는 라이브러리를 사용해야합니다.
- C11에서느 POSIX의 호환과 상관없이 표준 C를 사용하는 모든 시스템에서 사용할 수 있는 표준 스레딩 라이브러리를 제공합니다. C11표준에서 볼 수 있는 가장 큰 변화입니다.
- 유감스럽게도 C11 스레딩은 리눅스와 macOS에서는 구현되지 않았습니다.
- C18 표준은 C11에서 수정한 모든 내용을 포함하며, 새로운 기능은 도입되지 않았습니다.
