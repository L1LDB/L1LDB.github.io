---
title: "🐹 chap1. 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?"
author: chaeshee0908
date: 2023-09-23 20:00:00 +09:00
categories:
  [모던 자바 인 액션, "chap1. 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?"]
tags: [모던 자바 인 액션, JAVA, 1주차, 채승희]
render_with_liquid: false
math: true
---

JDK(Java Development Kit) 자바 개발 키트

# 1.1 역사의 흐름은 무엇인가?

```java
// 사과 목록을 무게순으로 정렬
Collections.sort(inventory, new Comparator<Apple>() {
		public int compare(Apple a1, Apple a2) {
				return a1.getWeight().compareTo(a2.getWeight());
		}
});
```

자바8을 이용하면 위에 코드를 자연어에 더 가깝게 간단한 방식으로 코드 구현이 가능하다.

```java
inventory.sort(comparing(Apple::getWeight));
```

자바는 병렬 실행 환경을 쉽게 관리하고 에러가 덜 발생하는 방향으로 진화하려 노력했다. 

- **자바 1.0**: 스레드, 락, 메모리 모델 지원
    - 이와 같은 저수준 기능을 온전히 활용하기는 어려웠음
- **자바 5**: 스레드 풀, 병렬 실행 컬렉션 등 강력한 도구 도입
- **자바 7**: 병렬 실행에 도움을 줄 수 있는 포크/조인 프레임워크를 제공
    - 하지만 여전히 개발자가 활용하기 쉽지 않았음

## 혁신의 자바8

자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용이라는 두 가지 요구사항을 기반으로 함

자바 8에서 제공하는 새로운 기술

- 스트림 API
- 메서드에 코드를 전달하는 기법
- 인터페이스의 디폴트 메서드

### [ 스트림 ]

: 데이터베이스 질의 언어에서 표현식을 처리하는 것처럼 병렬 연산을 지원하는 스트림이라는 새로운 API 제공

- SQL에서 고수준 언어로 원하는 동작을 표현하면, 구현에서 최적의 저수준 실행방법을 선택하는 방식으로 동작함
    
    → 스트림을 이용하면 synchronized 키워드를 사용하지 않아도 된다!
    
    (synchronized: 에러 자주 발생, 멀티코어 CPU를 이용하는 것보다 훨씬 비용 비쌈)
    

### [ 스트림 덕분에 존재하는 2가지 기능 ]

- **코드를 전달하는 간결 기법**(메서드 참조와 람다)
    - 약간만 다른 두 메서드를 인수를 이용해 다른 동작을 하도록 하나의 메서드로 합친다.
        
        → 프로그램이 짧고 간결해지고, 불필요한 에러도 줄일 수 있다.
        
- 인터페이스의 **디폴트 메서드** 존재

자바8 기법은 **함수형 프로그래밍**에서 위력을 발휘한다. 

# 1.2 왜 아직도 자바는 변화하는가?

- **C, C++**
    - 프로그래밍 안전성은 부족하지만 작은 런타임 풋프린트 덕분에 **운영체제**와 다양한 **임베디드 시스템**       에서 여전히 인기
    - 낮은 안정성 때문에 프로그램이 예기치 않게 종료되거나 바이러스 등이 침투할 수 있는 보안 구멍이 있을 수 있음

→ 런타임 풋프린트에 여유가 있는 애플리케이션에서는 **자바**, **C#** 같이 안전한 형식의 언어가 C, C++를 압도함

## 1.2.1 프로그래밍 언어 생태계에서 자바의 위치

### [ 자바의 시작 ]

- 처음부터 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작
- 처음부터 스레드와 락을 이용한 소소한 동시성도 지원
- 코드를 JVM 바이트 코드로 컴파일하는 특징(모든 브라우저에서 가상 머신 코드를 지원) 때문에 자바는 인터넷 애플릿 프로그램의 주요 언어가 되었다.

### [ 자바는 어떻게 대중적인 프로그래밍 언어로 성장했는가? ]

- 객체지향의 각광
    1. 캡슐화 덕분에 C에 비해 소프트웨어 엔지니어링적인 문제가 훨씬 적음
    2. 객체지향의 정신적인 모델 덕분에 윈도우 95 및 그 이후의 WIMP 프로그래밍 모델에 쉽게 대응할 수 있음
    
    → ‘모든 것은 객체다’로 요약할 수 있다. 
    

### [ 프로그래밍 언어 생태계에 변화의 바람 ]

프로그래머는 빅데이터(TB 이상의 데이터셋)에 도전하면서 멀티코어 컴퓨터나 컴퓨터 클러스팅을 이용하여 데이터를 효과적으로 처리할 필요성이 커졌고, 병렬 프로세싱을 활용해야 하는데 지금까지의 자바로는 충분히 대응할 수 없었다 .

**자바 8**은 더 다양한 프로그래밍 도구, 다양한 프로그래밍 문제를 더 빠르고 쉽게 유지보수할 수 있다는 장점을 제공한다. 

**자바8, 자바9**에서는 외부의 큰 하위시스템 컴포넌트를 추가하거나 다른 벤더가 만든 컴포넌트를 이용해 개발하는 사례가 늘고있고, 이런 설계 스타일에 적용할 수 있도록 **디폴트 메소드와 모듈을 제공**한다.

## 1.2.2 스트림 처리

**스트림**: 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임

### [ 스트림 패키지 ]

- 자바 8에는 **java.util.stream** 패키지에 스트림 API가 추가되었다.
- 스트림 패키지에 정의된 **Stream<T>**는 T 형식으로 구성된 일련의 항목을 의미한다.

### [ 스트림 API 장점 ]

- ‘스트림 API는 파이프라인을 만드는 데 필요한 많은 메서드 제공
- 기존에는 한 번에 한 항목을 처리했지만 자바 8에서는 우리가 하려는 작업을 **(데이터베이스 쿼리처럼) 고수준으로 추상화**해서 일련의 스트림으로 만들어 처리할 수 있다.
- 스트림 파이프라인을 이용해서 입력 부분을 **여러 CPU 코어**에 쉽게 할당 가능
    
    → 스레드라는 복잡한 작업을 사용하지 않으면서도 공짜로 병렬성을 얻을 수 있다.
    

## 1.2.3 동작 파라미터화로 메서드에 코드 전달하기

**동적 파라미터화**: 메서드(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능

- 동적 파라미터화의 예시
    
    2013UK0001, 2014US0002, … 등의 형식을 갖는 송장 ID가 있다. 처음 4개의 숫자는 연도, 다음 두 글자는 국가 코드를, 마지막 4개의 숫자는 고객 ID를 의미한다. 이 송장 ID를 고객 ID 또는 국가 코드순으로 정렬해야 한다. 이때 sort가 고객 ID나 국가 코드로 송장 ID를 정렬하도록 sort에 따로 코드를 제공해야 한다.
    
    송장 ID를 비교하는 **compareUsingCustomerId 메서드**를 구현하여 **sort 메서드**의 인수로 전달해준다. 이를 **동적 파라미터화**라고 한다. 
    
    ![](/assets/img/chaeshee0908/java-in-action/chap1/1.png){: width="500" }
    

## 1.2.4 병렬성과 공유 가변 데이터

서로 다른 코드를 동시에 실행할 때 **안전하게 실행**할 수 있는 코드를 만들기 위해서는 **공유된 가변 데이터**에 접근하지 않아야 한다.

→ 이러한 함수를 순수 함수, 부작용 없는 함수, 상태 없는 함수라 부른다.

### [ 병렬성 문제 해결 방안 ]

공유된 변수나 객체가 있으면 병렬성에 문제가 발생한다. 예를 들어 두 프로세스가 공유된 변수를 동시에 바꾸려 하면 어떻게 될까?

- 기존처럼 synchronized를 이용해서 공유된 가변 데이터를 보호하는 규칙을 만들 수 있을 것이다.
    
    → 일반적으로 synchronized는 시스템 성능에 악영향을 미침
    
    다중 프로세싱 코어에서 synchronized를 사용하면 코드가 순차적으로 실행되어야 하므로 병렬이라는 목적을 무력화시키면서 훨씬 더 비싼 대가를 치러야 할 수 있다.
    
- 자바 8 스트림을 이용하여 기존의 자바 스레드 API보다 쉽게 병렬성을 활용할 수 있다.

## 1.2.5 자바가 진화해야 하는 이유

### [ 자바의 진화 ]

- 제네릭(generic)의 등장
- List → List<String>
- 틀에 박힌 Iterator 대신 for-each 루프 사용

기존 값을 변화시키는 데 집중했던 고전적인 객체지향에서 벗어나 함수형 프로그래밍으로 다가섰다는 것이 자바 8의 가장 큰 변화다. 

### [ 함수형 프로그래밍 ]

- 우리가 하려는 작업이 최우선시 되며 그 작업을 어떻게 수행하는지는 별개의 문제로 취급
- 전통적인 객체지향 프로그래밍과는 상극
- 자바 8에서 함수형 프로그래밍을 도입함으로써 두 가지 프로그래밍 패러다임의 장점을 모두 활용

# 1.3 자바 함수

자바 프로그램에서 조작할 수 있는 값(일급 값)

- int 형식, double 형식 등의 기본 값
- 객체(객체의 참조값) - 객체 참조는 클래스의 **인스턴스**를 가리킨다.
    - new 또는 팩토리 메서드 또는 라이브러리 함수를 이용해서 객체의 값을 얻을 수 있다.

## 1.3.1 메서드와 람다를 일급 시민으로

자바 8에서는 메서드를 값으로 취급할 수 있게 하여 프로그래머들이 더 쉽게 프로그램을 구현할 수 있는 환경이 제공되도록 자바 8을 설계함

### [ 메서드 참조 기능 ]

ex) 디렉토리에서 모든 숨겨진 파일을 필터링한다. 

![](/assets/img/chaeshee0908/java-in-action/chap1/2.png){: width="500" }

위의 코드는 각 행이 무슨 작업을 하는지 투명하지 않다. 이미 isHidden() 이라는 메서드가 있는데 굳이 FileFilter로 복잡하게 감싼 후 FileFilter를 인스턴스화 해야하나? 이것을 자바 8에서는 아래 코드로 변경 가능하다

![](/assets/img/chaeshee0908/java-in-action/chap1/3.png){: width="500" }

자바 8의 메서드 참조 `::`를 이용하여 listFiles에 직접 전달할 수 있다.

![](/assets/img/chaeshee0908/java-in-action/chap1/4.png){: width="650" }

기존에 비해 문제 자체를 더 직접적으로 설명한다는 점이 자바 8 코드의 장점이다.

자바 8에서는 **기명 메서드**와 **람다 함수**를 모두 값으로 취급할 수 있다. 

## 1.3.2 코드 넘겨주기 : 예제

Apple 클래스와 getColor 메서드가 있고, Apples 리스트를 포함하는 변수 inventory가 있다고 가정하자.

이때 모든 녹색 사과를 선택해서 리스트를 반환하는 프로그램을 구현하고자 한다.(필터)

- 자바 8 이전 filterGreenApples
    
    ![](/assets/img/chaeshee0908/java-in-action/chap1/5.png){: width="500" .normal }
    
    사과 무게로 필터링 하고싶을 수도 있다. 
    
    ![](/assets/img/chaeshee0908/java-in-action/chap1/6.png){: width="500" .normal }
    
    첫번째 코드를 복붙하여 위 코드를 구현할 수 있다. 
    
    소프트웨어공학적인 면에서 해당 코드에 버그가 있다면 복붙한 모든 코드를 고쳐야 한다는 단점이 있다. 
    
- 자바 8 이후
    
    코드를 인수로 넘겨줄 수 있으므로 filter 메서드를 중복으로 구현할 필요가 없다. 
    
    ![](/assets/img/chaeshee0908/java-in-action/chap1/7.png){: width="400" .normal }
    
    ![](/assets/img/chaeshee0908/java-in-action/chap1/8.png){: width="600" .normal }
    
    다음처럼 메서드를 호출할 수 있다.
    
    ![](/assets/img/chaeshee0908/java-in-action/chap1/9.png){: width="350" .normal }
    
    ![](/assets/img/chaeshee0908/java-in-action/chap1/10.png){: width="350" .normal }
    

## 1.3.3 메서드 전달에서 람다로

메서드를 값으로 전달하는 것은 유용하지만, 한두 번만 사용할 메서드를 매번 정의하는 것은 귀찮은 일이다. 

자바 8에서 람다(익명 함수)를 사용해 코드를 구현할 수 있다.

![](/assets/img/chaeshee0908/java-in-action/chap1/11.png){: width="450" .normal }

![](/assets/img/chaeshee0908/java-in-action/chap1/12.png){: width="450" .normal }

![](/assets/img/chaeshee0908/java-in-action/chap1/13.png){: width="450" .normal }

즉, 한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없다.

하지만 람다가 몇 줄 이상으로 길어진다면, 익명 람다보다는 코드가 수행하는 일을 잘 설명하는 이름을 가진 메서드를 정의하고 메서드 참조를 활용하는 것이 바람직하다. (코드의 명확성 우선)

# 1.4 스트림

컬렉션은 자바에서 대부분 만들어 활용하지만, 컬렉션으로 모든 문제가 해결되지는 않는다. 

예를 들어 리스트에서 고가의 트랜잭션(거래)만 필터링한 다음에 통화로 결과를 그룹화해야 할 때 다음과 같이 많은 기본 코드를 구현해야 한다.

![](/assets/img/chaeshee0908/java-in-action/chap1/14.png){: width="550" }

게다가 위 예제 코드에서 중첩된 제어 흐름 문장이 많아서 코드를 한 번에 이해하기도 어렵다.

스트림 API를 이용하면 다음처럼 문제를 해결할 수 있다.

![](/assets/img/chaeshee0908/java-in-action/chap1/15.png){: width="600" }

스트림 API를 이용하면 컬렉션 API와는 상당히 다른 방식으로 데이터를 처리할 수 있다. 

- 컬렉션에서는 반복과정을 직접 처리해야 했다(for-each 루프를 이용해 각 요소 반복 작업). 이를 외부 반복이라 한다.
- 스트림 API를 이용하면 루프를 신경쓸 필요가 없다. 스트림 API에서는 라이브러리 내부에서 모든 데이터가 처리된다. 이를 내부 반복이라고 한다.

### [ 멀티코어 컴퓨터 ]

단일 CPU가 아닌 4 또는 8개 이상의 CPU를 갖는다. 전통적 자바 프로그램은 많은 CPU 중 단 하나만을 사용해 나머지 CPU를 낭비시키는 문제가 있었다. 대량의 데이터를 효과적으로 처리할 수 있도록 자바 8에서는 새로운 프로그래밍 스타일을 제공한다. 

## 1.4.1 멀티스레딩은 어렵다

멀티스레딩 코드를 구현하여 병렬성을 이용하여 결과적으로 스레드를 잘 제어하지 못하면 원치않는 방식으로 데이터가 변할 수 있다. 

멀티스레딩 모델은 순차적인 모델보다 다루기가 어렵다

![](/assets/img/chaeshee0908/java-in-action/chap1/16.png){: width="650" }

위는 두 스레드가 적절히 제어되지 않았을 때 나올 수 있는 문제이다. 

자바 8의 스트림 API로 ’컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제’ 그리고 ‘멀티코어 활용 어려움’이라는 두 가지 문제를 모두 해결했다. 

반복되는 패턴(SQL과 같은 DB 쿼리와 비슷한)을 주어진 조건에 따라 **필터링** 하거나, 데이터를 **추출**하거나, 데이터를 **그룹화**하는 등의 기능이 있다. 

![](/assets/img/chaeshee0908/java-in-action/chap1/17.png){: width="600" }

1. **포킹 단계**: 리스트를 필터링할 때 한 CPU는 리스트의 앞부분을 처리하고, 다른 CPU는 리스트의 뒷부분을 처리하도록 요청
2. **필터 단계**: 각각의 CPU는 자신이 맡은 절반의 리스트를 처리한다.
3. **결과 합침**: 마지막으로 하나의 CPU가 두 결과를 정리한다.

스트림은 스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환경을 제공한다.

컬렉션을 필터링할 수 있는 가장 빠른 방법은 컬렉션을 스트림으로 바꾸고, 병렬로 처리한 다음에, 리스트로 다시 복원하는 것이다. 

- 순차 처리 방식의 코드
    
    ![](/assets/img/chaeshee0908/java-in-action/chap1/18.png){: width="500" .normal }
    
- 병렬 처리 방식의 코드
    
    ![](/assets/img/chaeshee0908/java-in-action/chap1/19.png){: width="530" .normal }
    

# 1.5 디폴트 메서드와 자바 모듈

요즘은 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는 경향이 있다. 이전 자바에서는 평범한 패키지 집합을 포함하는 JAR 파일을 제공하는 것이 전부였고, 해당 패키지의 인터페이스를 바꾸는 상황에서 모든 클래스의 구현을 바꿔야 했으므로 엄청난 비용이 들었다. 

자바 8과 자바 9에서 이를 다른 방법으로 해결했다. 

- **자바 9**: 모듈 시스템은 모듈을 정의하는 분법을 제공하므로 이를 이용해 패키지 모음을 포함하는 모듈을 정의할 수 있다. **모듈 덕분에 JAR 같은 컴포넌트에 구조를 적용**할 수 있으며 문서화와 모듈 확인 작업이 용이해졌다.
- **자바 8**: 인터페이스를 쉽게 바꿀 수 있도록 **디폴트 메서드**를 지원한다.

자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공한다. 

메서드 본문은 클래스 구현이 아니라 인터페이스의 일부로 포함된다. → 디폴트 메서드라고 부른다.

### [ 디폴트 메서드 ]

- 디폴트 메서드를 이용하면 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다.
- 자바 8에서는 인터페이스 규격명세에 default라는 키워드를 지원한다.

ex) 자바 8에서는 List에 직접 sort 메서드를 호출할 수 있다 (List 인터페이스에 다음과 같은 디폴트 메서드 정의가 추가되었기 때문이다. → 이 디폴트 메서드는 정적 메서드인 Collections.sort를 호출한다.)

![](/assets/img/chaeshee0908/java-in-action/chap1/20.png){: width="350" }

따라서 자바 8 이전에는 List를 구현하는 모든 클래스가 sort를 구현해야 했지만 자바 8부터는 디폴트 sort를 구현하지 않아도 된다. 

하나의 클래스에서 여러 인터페이스를 구현한다. → 여러 인터페이스에 다중 디폴트 메서드가 존재할 수 있다는 것은 다중 상속이 허용된다는 것인가? 

⇒ 엄밀히 말하면 다중 상속은 아니지만 어느 정도는 ‘그렇다’라고 말할 수 있다.

# 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

### [ null을 회피하는 기법 ]

자바 8에서는 NullPointer 예외를 피할 수 있도록 도와주는 **Optional<T>** 클래스를 제공한다.

- **Optional<T>**
    - 값을 갖거나 갖지 않을 수 있는 컨테이너 객체
    - 값이 없는 상황을 어떻게 처리할지 명시적으로 구현하는 메서드 포함