---
title: "ğŸ£ chap8. ì»¬ë ‰ì…˜ API ê°œì„ "
author: olive-su
date: 2023-12-03 20:00:00 +09:00
categories: [ëª¨ë˜ ìë°” ì¸ ì•¡ì…˜, "chap8. ì»¬ë ‰ì…˜ API ê°œì„ "]
tags: [ëª¨ë˜ ìë°” ì¸ ì•¡ì…˜, JAVA, 7ì£¼ì°¨, ê¹€ìˆ˜ê²½]
render_with_liquid: false
math: true
---

# 8.1 ì»¬ë ‰ì…˜ íŒ©í† ë¦¬

A, B, Cë¥¼ í¬í•¨í•˜ëŠ” ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“ ë‹¤.

```
List<String> friends = new ArrayList<>();
friends.add("A");
friends.add("B");
friends.add("C");
```

```
List<String> friends = Arrays.asList("A", "B", "C");
```

### UnsupportedOperationException ì˜ˆì™¸ ë°œìƒ

```
friends.add("D");
```

ê³ ì • í¬ê¸° ë°°ì—´ë¡œ ë§Œë“¤ì–´ì§

### Set ë§Œë“¤ê¸°

```
Set<String> friends = new HashSet<>(
Arrays.asList("A", "B", "C")
);
```

í˜¹ì€ stream APIë¥¼ ì‚¬ìš©í•œë‹¤.

```
Set<String> friends = Stream.of("A", "B", "C")
.collect(Collectors.toSet());
```

ë‘ ë°©ë²• ëª¨ë‘ ë¶ˆí•„ìš”í•œ ë‹¨ê³„ í•˜ë‚˜ì”©ì„ ê±´ë„ˆì•¼ í•˜ê³ , ë§¤ë„ëŸ½ì§€ ëª»í•˜ê³  ë‚´ë¶€ì ìœ¼ë¡œ
ë¶ˆí•„ìš”í•œ ê°ì²´ í• ë‹¹ì„ í•„ìš”ë¡œ í•œë‹¤.

ìë°”9ì—ì„œ ë¦¬ìŠ¤íŠ¸, ì§‘í•©, ë§µì„ ì‰½ê²Œ ë§Œë“¤ ìˆ˜ ìˆëŠ”Â **íŒ©í† ë¦¬ ë©”ì„œë“œ**ë¥¼ ì§€ì›í•¨

## 8.1.1 ë¦¬ìŠ¤íŠ¸ íŒ©í† ë¦¬

### List.of

```
List<String> friends = List.of("A", "B", "C");
System.out.println(friends);
```

- addë¥¼ í•˜ë©´ ì—ëŸ¬ ë°œìƒ
- ìœ„ ë¦¬ìŠ¤íŠ¸ëŠ” ë¶ˆë³€ ë¦¬ìŠ¤íŠ¸
- set() X
- null ìš”ì†Œë„ ë¶ˆê°€

### ì˜¤ë²„ë¡œë”©

```
static <E> List<E> of(E e1, E e2, E e3);
static <E> List<E> of(E e1, E e2, E e3, E e4);
static <E> List<E> of(E... elements);
```

ìµœì í™”ë¥¼ ìœ„í•œ ì˜¤ë²„ë¡œë”©

## 8.1.2 ì§‘í•© íŒ©í† ë¦¬

```
Set<String> friends = Set.of("A", "B", "C");

System.out.println(friends);
```

of ë¥¼ í†µí•´ ì œê³µí•œ ìš”ì†Œ ì¤‘ ì¤‘ë³µì´ ìˆìœ¼ë©´ IllegalArgumentException ë¦¬í„´

## 8.1.3 ë§µ íŒ©í† ë¦¬

```
Map<String, Integer> ageOfFriends =
Map.of("A", 1, "B", 2, "C", 3);
```

10ê°œ ì´í•˜ì˜ í‚¤ì™€ ê°’ ìŒì„ ê°€ì§„ ì‘ì€ ë§µ ìœ ìš©

10ê°œ ì´ìƒì˜ ë§µì€ Map.Entry<K, V> ê°ì²´ë¥¼ ì¸ìˆ˜ë¡œ ë°›ëŠ” ê°€ë³€ ì¸ìˆ˜ë¡œ êµ¬í˜„ëœ Map.ofEntries íŒ©í† ë¦¬ ë©”ì„œë“œë¥¼ ì´ìš©

```
import static java.util.Map.entry;

Map<String, Integer> ageOfFriends = Map.ofEntries(
entry("A", 1),
entry("B", 2),
entry("C", 3)
);
```

# 8.2 ë¦¬ìŠ¤íŠ¸ì™€ ì§‘í•© ì²˜ë¦¬

ìë°” 8ì—ì„œëŠ” List, Set ì¸í„°í˜ì´ìŠ¤ì— ë‹¤ìŒê³¼ ê°™ì€ ë©”ì„œë“œë¥¼ ì¶”ê°€í–ˆë‹¤.

- removeIf : í”„ë ˆë””ì¼€ì´íŠ¸ë¥¼ ë§Œì¡±í•˜ëŠ” ìš”ì†Œë¥¼ ì œê±°í•œë‹¤.
- replaceAll : UnaryOperator í•¨ìˆ˜ë¥¼ ì´ìš©í•´ ìš”ì†Œë¥¼ ë°”ê¾¼ë‹¤. ë¦¬ìŠ¤íŠ¸ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
- sort : ë¦¬ìŠ¤íŠ¸ë¥¼ ì •ë ¬í•œë‹¤.

ì´ ë©”ì„œë“œëŠ” ìƒˆë¡œìš´ ê²°ê³¼ë¥¼ ë§Œë“œëŠ” ìŠ¤íŠ¸ë¦¼ ë™ì‘ê³¼ ë‹¬ë¦¬ í˜¸ì¶œí•œ ê¸°ì¡´ ì»¬ë ‰ì…˜ ìì²´ë¥¼ ë°”ê¾¼ë‹¤.

ì»¬ë ‰ì…˜ì„ ë°”ê¾¸ëŠ” ë™ì‘ì€ ì—ëŸ¬ë¥¼ ìœ ë°œí•˜ë©° ë³µì¡í•¨ì„ ë”í•˜ê¸° ë•Œë¬¸ì— ìë°” 8ì—ì„œëŠ” removeIfì™€ replaceAllì„ ì¶”ê°€í–ˆë‹¤.

## 8.2.1 removeIf ë©”ì„œë“œ

ë‹¤ìŒì€ ìˆ«ìë¡œ ì‹œì‘ë˜ëŠ” ì°¸ì¡° ì½”ë“œë¥¼ ê°€ì§„ íŠ¸ëœì­ì…˜ì„ ì‚­ì œí•˜ëŠ” ì½”ë“œë‹¤.

```
for(Transaction transaction : transactions) {
  if(Character.isDigit(transaction.getReferenceCode().charAt(0))) {
    transaction.remove(transaction);
  }
}
```

ì½”ë“œë¥¼ ì‹¤í–‰í•´ë³´ë©´ ConcurrentModificationExceptionì„ ì¼ìœ¼í‚¨ë‹¤.

forEach ë£¨í”„ëŠ” Iterator ê°ì²´ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ ìœ„ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì´ í•´ì„ëœë‹¤.

```
for(Iterator<Transaction> iterator = transactions.iterator(); iterator.hasNext(); ) {
  Transaction transaction = iterator.next();
  if(Character.isDigit(transaction.getReferenceCode().charAt(0))) {
    transactions.remove(transaction);
    // ë°˜ë³µìë¥¼ ì‚¬ìš©í•´ ë¦¬ìŠ¤íŠ¸ë¥¼ ìˆœíšŒí•˜ë©´ì„œ, ë¦¬ìŠ¤íŠ¸ë¥¼ ì§ì ‘ ìˆ˜ì •í•˜ê³  ìˆìŒ -> ë¬¸ì œ ë°œìƒ
  }
}
```

Iterator ê°ì²´ë¥¼ í†µí•´ ì†ŒìŠ¤ë¥¼ ì§ˆì˜í•˜ê³ , Collection ê°ì²´ ìì²´ì— remove()ë¥¼ í˜¸ì¶œí•´ ìš”ì†Œë¥¼ ì‚­ì œí•˜ê³  ìˆë‹¤.

ë”°ë¼ì„œ ë°˜ë³µìì˜ ìƒíƒœì™€ ì»¬ë ‰ì…˜ì˜ ìƒíƒœê°€ ë™ê¸°í™”ë˜ì§€ ì•ŠëŠ”ë‹¤.

Iterator ê°ì²´ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì‚¬ìš©í•˜ê³  ê·¸ ê°ì²´ì˜ remove() ë©”ì„œë“œë¥¼ í˜¸ì¶œí•´ì¤˜ì•¼ ì •ìƒì ìœ¼ë¡œ ë™ì‘í•œë‹¤.

```
for(Iterator<Transaction> iterator = transactions.iterator(); iterator.hasNext(); ) {
  Transaction transaction = iterator.next();
  if(Character.isDigit(transaction.getReferenceCode().charAt(0))) {
    iterator.remove();
  }
}
```

ìœ„ì˜ ë³µì¡í•œ ì½”ë“œ íŒ¨í„´ì€ ìë°” 8ì˜ removeIf ë©”ì„œë“œë¡œ ë°”ê¿€ ìˆ˜ ìˆë‹¤. removeIfëŠ” ì‚­ì œí•  ìš”ì†Œë¥¼ ê°€ë¦¬í‚¤ëŠ” í”„ë ˆë””ì¼€ì´íŠ¸ë¥¼ ì¸ìˆ˜ë¡œ ë°›ëŠ”ë‹¤.

```
transactions.removeIf(transaction ->
  Character.isDigit(transaction.getReferenceCode().charAt(0))); // Trueì¸ ê²½ìš° ì œê±°
```

## 8.2.2 replaceAll ë©”ì„œë“œ

replaceIfì²˜ëŸ¼ ìš”ì†Œë¥¼ ì œê±°í•˜ëŠ” ê²Œ ì•„ë‹ˆë¼ ë°”ê¿”ì•¼ í•˜ëŠ” ìƒí™©ì¼ ë•Œ, replaceAllì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

List ì¸í„°í˜ì´ìŠ¤ì˜ replaceAll ë©”ì„œë“œë¥¼ ì´ìš©í•´ ë¦¬ìŠ¤íŠ¸ì˜ ê° ìš”ì†Œë¥¼ ìƒˆë¡œìš´ ìš”ì†Œë¡œ ë°”ê¿€ ìˆ˜ ìˆë‹¤.

ì•„ë˜ëŠ” ìŠ¤íŠ¸ë¦¼ APIë¥¼ ì‚¬ìš©í•œ ì˜ˆì œì´ë‹¤.

```
referenceCodes.stream() // [a12, C14, b13]
    .map(code -> Character.toUpperCase(code.charAt(0)) + code.subString(1))
    // ìŠ¤íŠ¸ë¦¼ì˜ ê° ìš”ì†Œì— ëŒ€í•´ í•¨ìˆ˜ë¥¼ ì ìš©í•˜ì—¬ ìƒˆë¡œìš´ ìŠ¤íŠ¸ë¦¼ì„ ìƒì„±
    .collect(Collectors.toList())
    .forEach(System.out::println);
```

```
// ê²°ê³¼
A12
C14
B13

```

í•˜ì§€ë§Œ ì´ ì½”ë“œëŠ” ìƒˆ ë¬¸ìì—´ ì»¬ë ‰ì…˜ì„ ë§Œë“ ë‹¤. ê¸°ì¡´ ì»¬ë ‰ì…˜ì„ ë°”ê¾¸ë ¤ë©´ ListIterator ê°ì²´ë¥¼ ì´ìš©í•´ì•¼ í•œë‹¤.

```
for(ListIterator<String> iterator = referenceCodes.listIterator(); iterator.hasNext(); ) {
  String code = iterator.next();
  iterator.set(Character.toUpperCase(code.charAt(0)) + code.substring(1));
  // ë³€ê²½ëœ ê°’ì„ iterator.set() ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ í˜„ì¬ ìš”ì†Œì— ëŒ€ì…í•˜ì—¬ ìˆ˜ì •
}
```

ì½”ë“œê°€ ë³µì¡í•´ì¡Œë‹¤. ê·¸ë¦¬ê³  ì´ì²˜ëŸ¼ ì»¬ë ‰ì…˜ ê°ì²´ì™€ Iterator ê°ì²´ë¥¼ í˜¼ìš©í•˜ë©´ ë°˜ë³µê³¼ ë³€ê²½ì´ ë™ì‹œì— ì´ë£¨ì–´ì ¸ ì‰½ê²Œ ë¬¸ì œë¥¼ ì¼ìœ¼í‚¨ë‹¤.

ìë°” 8ì˜ replaceAll ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ë©´ ê°„ë‹¨í•˜ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

```
referenceCodes.replaceAll(code -> Character.toUpperCase(code.charAt(0)) + code.substring(1));
```

ë‹¤ìŒ 8.3ì ˆì—ì„œëŠ” Map ì¸í„°í˜ì´ìŠ¤ì— ì¶”ê°€ëœ ìƒˆ ê¸°ëŠ¥ì„ ì„¤ëª…í•œë‹¤.

# 8.3. ë§µ ì²˜ë¦¬

ìë°” 8ì—ì„œëŠ” Map ì¸í„°í˜ì´ìŠ¤ì— ë””í´íŠ¸ ë©”ì†Œë“œë¥¼ ì¶”ê°€í–ˆë‹¤.

### 8.3.1. forEach ë©”ì†Œë“œ

ë§µì—ì„œ í‚¤ì™€ ê°’ì„ ë°˜ë³µí•˜ëŠ” ì‘ì—…ì„ ìœ„í•´ ìë°” 8ì—ì„œë¶€í„° Map ì¸í„°í˜ì´ìŠ¤ëŠ” BiConsumer(í‚¤ì™€ ê°’ì„ ì¸ìˆ˜ë¡œ ë°›ìŒ)ë¥¼ ì¸ìˆ˜ë¡œ ë°›ëŠ”Â `forEach`Â ë©”ì†Œë“œë¥¼ ì œê³µí•œë‹¤.

```
// forEach ë©”ì†Œë“œ ë¯¸ì‚¬ìš©
for (Map.Entry<String, Integer> entry : ageOfFriends.entrySet()) {
    String friend = entry.getKey();
    Integer age = entry.getValue();
    System.out.println(friend + " is " + age + " years old");
}

// forEach ë©”ì†Œë“œ ì‚¬ìš©
ageOfFriends.forEach((friend, age) -> System.out.println(friend + " is " + age + " years old"));
```

### 8.3.2 ì •ë ¬ ë©”ì†Œë“œ

`Entry.comparingByValue`,Â `Entry.comparingByKey`ë¥¼ ì´ìš©í•˜ë©´ ë§µì˜ í•­ëª©ì„ ê°’ ë˜ëŠ” í‚¤ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•  ìˆ˜ ìˆë‹¤.

```
Map<String, String> favouriteMovies = Map.ofEntries(entry("Raphael", "Star Wars"),
        entry("Cristina", "Matrix"),
        entry("Olivia", "James Bond"));

favouriteMovies.entrySet()
        .stream()
        .sorted(Entry.comparingByKey()) // ì‚¬ëŒì˜ ì´ë¦„ì„ ì•ŒíŒŒë²³ ìˆœìœ¼ë¡œ ìŠ¤íŠ¸ë¦¼ ìš”ì†Œ ì²˜ë¦¬
        .forEachOrdered(System.out::println);
```

> HashMap ì„±ëŠ¥
>
> ìë°” 8ì—ì„œëŠ” HashMapì˜ ë‚´ë¶€ êµ¬ì¡°ë¥¼ ë°”ê¿” ì„±ëŠ¥ì„ ê°œì„ í–ˆë‹¤.
>
> ê¸°ì¡´ì˜ ë§µì˜ í•­ëª©ì€ ë§ì€ í‚¤ê°€ ê°™ì€ í•´ì‹œì½”ë“œë¥¼ ë°˜í™˜í•˜ëŠ” ìƒí™©ì´ ë˜ë©´ O(n)ì˜ ì‹œê°„ì´ ê±¸ë¦¬ëŠ” LinkedListë¡œ ë²„í‚·ì„ ë°˜í™˜í•´ì•¼ í•˜ë¯€ë¡œ ì„±ëŠ¥ì´ ì €í•˜ë˜ì—ˆë‹¤.
>
> ìµœê·¼ì—ëŠ” ë²„í‚·ì´ ë„ˆë¬´ ì»¤ì§€ë©´ O(log(n))ì˜ ì‹œê°„ì´ ì†Œìš”ë˜ëŠ” ì •ë ¬ëœ íŠ¸ë¦¬ë¥¼ ì´ìš©í•´ ë™ì ìœ¼ë¡œ ì¹˜í™˜í•´ ì¶©ëŒì´ ì¼ì–´ë‚˜ëŠ” ìš”ì†Œ ë°˜í™˜ ì„±ëŠ¥ì„ ê°œì„ í–ˆë‹¤. (í‚¤ê°€ Comparable í˜•íƒœì—¬ì•¼ ì •ë ¬ëœ íŠ¸ë¦¬ë¥¼ ì§€ì›)

### 8.3.3 getOrDefault ë©”ì„œë“œ

í‚¤ê°€ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ê²°ê³¼ê°€ nullì´ ë°˜í™˜ë˜ë¯€ë¡œ NullPointerExceptionì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ìš”ì²­ ê²°ê³¼ì˜ null ì—¬ë¶€ë¥¼ í™•ì¸í•´ì•¼ í–ˆë‹¤.

ê¸°ë³¸ê°’ì„ ë°˜í™˜í•˜ëŠ”Â `getOrDefault`Â ë©”ì„œë“œëŠ” ì²« ë²ˆì§¸ ì¸ìˆ˜ë¡œ í‚¤ë¥¼, ë‘ ë²ˆì§¸ ì¸ìˆ˜ë¡œ ê¸°ë³¸ê°’ì„ ë°›ì•„ ë§µì— í‚¤ê°€ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ë‘ ë²ˆì§¸ ì¸ìˆ˜ë¡œ ë°›ì€ ê¸°ë³¸ê°’ì„ ë°˜í™˜í•œë‹¤.

```
Map<String, String> favouriteMovies = Map.ofEntries(entry("Raphael", "Star Wars"), entry("Olivia", "James Bond"));

System.out.println(favouriteMovies.getOrDefault("Olivia", "Matrix"));   // James Bond ì¶œë ¥
System.out.println(favouriteMovies.getOrDefault("Thibaut", "Matrix"));  // Matrix ì¶œë ¥
```

í‚¤ê°€ ì¡´ì¬í•˜ë”ë¼ë„ ê°’ì´ nullì¸ ìƒí™©ì—ì„œëŠ”Â `getOrDefault`ê°€ nullì„ ë°˜í™˜í•  ìˆ˜ ìˆë‹¤.

### 8.3.4 ê³„ì‚° íŒ¨í„´

í‚¤ ì¡´ì¬ ì—¬ë¶€ì— ë”°ë¼ ì–´ë–¤ ë™ì‘ì„ ì‹¤í–‰í•˜ê³  ê²°ê³¼ë¥¼ ì €ì¥í•´ì•¼í•˜ëŠ” ìƒí™©ì´ í•„ìš”í•œ ë•Œê°€ ìˆë‹¤.

ë‹¤ìŒì˜ 3ê°€ì§€ ì—°ì‚°ì´ ì´ëŸ° ìƒí™©ì— ë„ì›€ì´ ëœë‹¤.

- `computeIfAbsent`Â : ì œê³µëœ í‚¤ì— í•´ë‹¹í•˜ëŠ” ê°’ì´ ì—†ìœ¼ë©´(í˜¹ì€ null) í‚¤ë¥¼ ì´ìš©í•´ ìƒˆ ê°’ì„ ê³„ì‚°í•˜ê³  ë§µì— ì¶”ê°€í•œë‹¤.
- `computeIfPresent`Â : ì œê³µëœ í‚¤ê°€ ì¡´ì¬í•˜ë©´ ìƒˆ ê°’ì„ ê³„ì‚°í•˜ê³  ë§µì— ì¶”ê°€í•œë‹¤.
- `compute`Â : ì œê³µëœ í‚¤ë¡œ ìƒˆ ê°’ì„ ê³„ì‚°í•˜ê³  ë§µì— ì €ì¥í•œë‹¤.
- Mapì„ ì´ìš©í•œ ìºì‹œ êµ¬í˜„

```
// ìºì‹œ
Map<String, byte[]> dataToHash = new HashMap<>();

// ê° ë¼ì¸ì„ SHA-256ì˜ í•´ì‹œ ê°’ìœ¼ë¡œ ê³„ì‚°í•´ì„œ ì €ì¥í•˜ê¸° ìœ„í•œ ê³„ì‚° ê°ì²´
MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");

// í‚¤ê°€ ì—†ë‹¤ë©´ lineê³¼ ê³„ì‚°ëœ í•´ì‹œ ê°’ì´ key,valueë¡œ ë“¤ì–´ê°
lines.forEach(line -> dataToHash.computeIfAbsent(line, this::calculateDigest));

// í‚¤ì˜ í•´ì‹œë¥¼ ê³„ì‚°í•´ì„œ ë°˜í™˜
private byte[] calculateDigest(String key) {
    return messageDigest.digest(key.getBytes(StandardCharsets.UTF_8));
}
```

- í‚¤ê°€ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ê°’ì„ ë°˜í™˜

ì•„ë˜ ì½”ë“œëŠ” í‚¤ê°€ ì¡´ì¬í•˜ë©´ ê¸°ì¡´ ê°’ì—, ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ìƒˆë¡œìš´ ë¦¬ìŠ¤íŠ¸ì— 'Star Wars'ê°€ ì¶”ê°€ ëœë‹¤.

```
friendsToMovies.computeIfAbsent("Raphael", name -> new ArrayList<>())
        .add("Star Wars");
```

### 8.3.5 ì‚­ì œ íŒ¨í„´

ìë°” 8ì—ì„œëŠ” í‚¤ê°€ íŠ¹ì •í•œ ê°’ê³¼ ì—°ê´€ë˜ì—ˆì„ ë•Œë§Œ í•­ëª©ì„ ì œê±°í•˜ëŠ” ì˜¤ë²„ë¡œë“œ ë²„ì „ ë©”ì„œë“œë¥¼ ì œê³µí•œë‹¤.

- ìë°” 8 ì´ì „

```
String key = "Raphael";
String value = "Jack Reacher 2";
if (favouriteMovies.containsKey(key) && Objects.equals(favouriteMovies.get(key), value)) {
   favouriteMovies.remove(key);
   return true;
} else {
   return false;
}
```

- ìë°” 8 ì´í›„

```
favouriteMovies.remove(key, value);
```

### 8.3.6 êµì²´ íŒ¨í„´

ë§µì˜ í•­ëª©ì„ ë°”ê¾¸ëŠ”ë° ì‚¬ìš©í•˜ëŠ” ë©”ì„œë“œ

- `replaceAll`Â : BiFunctionì„ ì ìš©í•œ ê²°ê³¼ë¡œ ê° í•­ëª©ì˜ ê°’ì„ êµì²´í•œë‹¤.
- `replace`Â : í‚¤ê°€ ì¡´ì¬í•˜ë©´ ë§µì˜ ê°’ì„ ë°”ê¾¼ë‹¤. í‚¤ê°€ íŠ¹ì • ê°’ìœ¼ë¡œ ë§¤í•‘ë˜ì—ˆì„ ë•Œë§Œ ê°’ì„ êµì²´í•˜ëŠ” ì˜¤ë²„ë¡œë“œ ë²„ì „ë„ ìˆë‹¤.

```
Map<String, String> favouriteMovies = new HashMap<>();
favouriteMovies.put("Raphael", "Star Wars");
favouriteMovies.put("Olivia", "james bond");

favouriteMovies.replaceAll((friend, movie) -> movie.toUpperCase());
```

### 8.3.7 í•©ì¹¨

`putAll`Â ë©”ì„œë“œë¥¼ ì´ìš©í•˜ì—¬ ë‘ ë§µì„ í•©ì¹  ìˆ˜ ìˆë‹¤.

ê·¸ëŸ¬ë‚˜Â `putAll`ì€ ì¤‘ë³µëœ í‚¤ê°€ ìˆë‹¤ë©´ ì œëŒ€ë¡œ ë™ì‘í•˜ì§€ ì•ŠëŠ”ë‹¤.

ì´ë•ŒëŠ” ì¤‘ë³µëœ í‚¤ë¥¼ ì–´ë–»ê²Œ í•©ì¹ ì§€ ê²°ì •í•˜ëŠ”Â `BiFunction`ì„ ì¸ìˆ˜ë¡œ ë°›ëŠ”
`merge`Â ë©”ì„œë“œë¥¼ ì‚¬ìš©

- putAll ì‚¬ìš©

```
Map<String, String> family = Map.ofEntries(entry("Teo", "Star Wars"), entry("Cristina", "James Bond"));
Map<String, String> friends = Map.ofEntries(entry("Raphael", "Star Wars"));

Map<String, String> everyone = new HashMap<>(family);
everyone.putAll(friends);
```

- merge ì‚¬ìš©

ì¤‘ë³µëœ í‚¤ê°€ ìˆìœ¼ë©´ ë‘ ê°’ì„ ì—°ê²°í•˜ê³  ì—†ìœ¼ë©´ (key, value) ê·¸ëŒ€ë¡œ ì €ì¥í•œë‹¤.

```
Map<String, String> everyone = new HashMap<>(family);
friends.forEach((key, value) -> everyone.merge(key, value, (movie1, movie2) -> movie1 + " & " + movie2));
System.out.println(everyone);
```

- mergeë¥¼ ì´ìš©í•œ ì´ˆê¸°í™” ê²€ì‚¬

ì›í•˜ëŠ” ê°’ì´ ì´ˆê¸°í™”ë˜ì–´ ìˆìœ¼ë©´ +1, ì´ˆê¸°í™” ë˜ì–´ìˆì§€ ì•Šì•„ nullì´ë©´ (movieName, 1) ì €ì¥í•œë‹¤.

```
moviesToCount.merge(movieName, 1L, (key, count) -> count + 1L);
```

# 8.4 ê°œì„ ëœ ConcurrentHashMap

## ConcurrentHashMap

- **ë™ì‹œì„± ì¹œí™”ì **ì´ë©°Â **ìµœì‹  ê¸°ìˆ **ì„ ë°˜ì˜í•œ HashMap ë²„ì „
- ë‚´ë¶€ ìë£Œêµ¬ì¡°ì˜Â **íŠ¹ì • ë¶€ë¶„ë§Œ ì ê°€**Â **ë™ì‹œ ì¶”ê°€, ê°±ì‹  ì‘ì—…**ì„ í—ˆìš©í•¨
- ë™ê¸°í™”ëœ Hashtable ë²„ì „ì— ë¹„í•´Â **ì½ê¸°/ì“°ê¸° ì—°ì‚° ì„±ëŠ¥ì´ ì›”ë“±**í•˜ë‹¤
- (ì°¸ê³ ë¡œ, í‘œì¤€ HashMapì€ ë¹„ë™ê¸°ë¡œ ë™ì‘í•¨)

```
public class ConcurrentHashMap<K,V> extends AbstractMap<K,V> implements ConcurrentMap<K,V>, Serializable {

	public V get(Object key) {}

	public boolean containsKey(Object key) { }

	public V put(K key, V value) {
		return putVal(key, value, false);
	}

	...

}
```

### ì°¸ê³  : Hashtable Class

```
public class Hashtable<K,V> extends Dictionary<K,V> implements Map<K,V>, Cloneable, java.io.Serializable {

	public synchronized int size() { }

	@SuppressWarnings("unchecked")
	public synchronized V get(Object key) { }

	public synchronized V put(K key, V value) { } }
```

- ë©”ì†Œë“œ ì „ì²´ì—Â `synchronized`Â í‚¤ì›Œë“œê°€ ì¡´ì¬ (ë©”ì†Œë“œ ì „ì²´ê°€ ì„ê³„êµ¬ì—­ìœ¼ë¡œ ì„¤ì •ë¨)
- ë‹¤ë§Œ, ë™ì‹œì— ì‘ì—…ì„ í•˜ë ¤í•´ë„ ê°ì²´ë§ˆë‹¤ Lockì„ í•˜ë‚˜ì”© ê°€ì§€ê³  ìˆê¸° ë•Œë¬¸ì— ë™ì‹œì— ì—¬ëŸ¬ ì‘ì—…ì„ í•´ì•¼í•  ë•Œ ë³‘ëª©í˜„ìƒì´ ë°œìƒí•  ìˆ˜ ë°–ì— ì—†ìŒ

### ì°¸ê³  : HashMap

```
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {

	public V get(Object key) {}
	public V put(K key, V value) {}

}
```

- `synchronized`Â í‚¤ì›Œë“œê°€Â ì¡´ì¬í•˜ì§€ ì•ŠìŒ
- `Map`Â ì¸í„°í˜ì´ìŠ¤ë¥¼Â êµ¬í˜„í•œ í´ë˜ìŠ¤ ì¤‘ì—ì„œ ì„±ëŠ¥ì´ ì œì¼ ì¢‹ë‹¤ê³  í•  ìˆ˜ ìˆìŒ
- `Multi-Thread`Â í™˜ê²½ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤ëŠ” íŠ¹ì§•

## 8.4.1. ì—°ì‚°

- `forEach`Â : ê° key-value ìŒì— ì£¼ì–´ì§„ ì•¡ì…˜ì„ ìˆ˜í–‰
- `reduce`Â : ëª¨ë“  key-value ìŒì„ ì œê³µëœ reduce í•¨ìˆ˜ë¥¼ ì´ìš©í•´ ê²°ê³¼ë¡œ í•©ì¹¨
- `search`Â : nullì´ ì•„ë‹Œ ê°’ì„ ë°˜í™˜í•  ë•Œê¹Œì§€ ê° key-value ìŒì— í•¨ìˆ˜ë¥¼ ì ìš©

### ì—°ì‚°ì˜ ì¢…ë¥˜

- key-valueë¡œ ì—°ì‚° :Â `forEach`,Â `reduce`,Â `search`
- keyë¡œ ì—°ì‚° :Â `forEachKey`,Â `reduceKeys`,Â `searchKeys`
- valueë¡œ ì—°ì‚° :Â `forEachValue`,Â `reduceValues`,Â `searchValues`
- Map.Entryë¡œ ì—°ì‚° :Â `forEachEntry`,Â `reduceEntries`,Â `searchEntries`

### ì—°ì‚°ì‹œ ìœ ì˜ì‚¬í•­

- ì•„ë˜ì˜ ì—°ì‚°ë“¤ì€ ConcurrentHashMapì˜ ìƒíƒœë¥¼ ì ê·¸ì§€ ì•Šê³  ì—°ì‚°ì„ ìˆ˜í–‰ â†’ ì—°ì‚°ì— ì œê³µí•œ í•¨ìˆ˜ëŠ”Â **ê³„ì‚°ì´ ì§„í–‰ë˜ëŠ” ë™ì•ˆ ë°”ë€” ìˆ˜ ìˆëŠ” ê°ì²´, ê°’, ìˆœì„œ ë“±ì— ì˜ì¡´í•˜ì§€ ì•Šì•„ì•¼ í•¨**
- ë³‘ë ¬ì„± ê¸°ì¤€ê°’(threshold)ë¥¼ ì§€ì •í•´ì•¼ í•¨
  - ë§µì˜ í¬ê¸°ê°€ ì£¼ì–´ì§„ ê¸°ì¤€ê°’ë³´ë‹¤ ì‘ìœ¼ë©´ ìˆœì°¨ì ìœ¼ë¡œ ì—°ì‚°ì„ ì‹¤í–‰í•¨
  - `ê¸°ì¤€ê°’ = 1`Â : ê³µí†µ ìŠ¤ë ˆë“œ í’€ì„ ì´ìš©í•´ ë³‘ë ¬ì„±ì„ ê·¹ëŒ€í™”í•¨
  - `ê¸°ì¤€ê°’ = Long.MAX_VALUE`Â : í•œ ê°œì˜ ìŠ¤ë ˆë“œë¡œ ì—°ì‚°ì„ ì‹¤í–‰í•¨
  - (SW ì•„í‚¤í…ì²˜ê°€ ê³ ê¸‰ ìˆ˜ì¤€ì˜ ìµœì í™”ê°€ ì•„ë‹ˆë¼ë©´) ê¸°ì¤€ê°’ ê·œì¹™ì„ ë”°ë¥´ëŠ” ê²ƒì´ ì¢‹ìŒ
  ```
  public class ConcurrentHashMap<K,V> extends AbstractMap<K,V> implements ConcurrentMap<K,V>, Serializable {
  	private static final int DEFAULT_CAPACITY = 16; // ë™ì‹œì— ì—…ë°ì´íŠ¸ë¥¼ ìˆ˜í–‰í•˜ëŠ” ì“°ë ˆë“œ ìˆ˜
  	private static final int DEFAULT_CONCURRENCY_LEVEL = 16;
  }
  ```
  - `DEFAULT_CONCURRENCY_LEVEL`Â : ë™ì‹œì— ì‘ì—… ê°€ëŠ¥í•œ ì“°ë ˆë“œ ìˆ˜
  - `DEFAULT_CAPACITY`Â : ë²„í‚·ì˜ ìˆ˜
  - ì¦‰,Â ì—¬ëŸ¬ ì“°ë ˆë“œì—ì„œ ConcurrentHashMap ê°ì²´ì— ë™ì‹œì— ë°ì´í„°ë¥¼ ì‚½ì…, ì°¸ì¡°í•˜ë”ë¼ë„ ê·¸ ë°ì´í„°ê°€ ë‹¤ë¥¸ ì„¸ê·¸ë¨¼íŠ¸ì— ìœ„ì¹˜í•˜ë©´ ì„œë¡œ ë½ì„ ì–»ê¸° ìœ„í•´Â ê²½ìŸí•˜ì§€ ì•ŠìŒ

### ì—°ì‚° í™œìš© ì˜ˆì œ

`reduceValues`ë¥¼ í™œìš©í•˜ì—¬ ë§µì˜ ìµœëŒ“ê°’ì„ ì°¾ëŠ” ì½”ë“œ

```
ConcurrentHashMap<String, Long> map = new ConcurrentHashMap<>();
long parallelismThreshold = 1;
Optional<Integer> maxValue = Optional.ofNullable(map.reduceValues(parallelismThreshold, Long::max));
```

- int, long, double ë“±ì˜ ê¸°ë³¸ê°’ì—ëŠ” ì „ìš© each reduce ì—°ì‚°ì´ ì œê³µë¨
  â†’ ì´ë¥¼ ì˜ í™œìš©í•˜ë©´ ë°•ì‹± ì‘ì—…ì„ í•  í•„ìš”ê°€ ì—†ê³ , íš¨ìœ¨ì ìœ¼ë¡œ ì‘ì—…ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆìŒ (ex:Â `reduceValuesToInt`,Â `reduceKeysToLong`)

## 8.4.2. ê³„ìˆ˜

- **ConcurrentHashMap**Â í´ë˜ìŠ¤ : Mapì˜ ë§¤í•‘ ê°œìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ”Â `mappingCount`Â ë©”ì„œë“œë¥¼ ì œê³µí•¨

  - í‚¤ì™€ ê°’ì˜Â ë§¤í•‘ì˜Â ìˆ˜

- ê¸°ì¡´ì˜ size ë©”ì„œë“œ ëŒ€ì‹  ìƒˆ ì½”ë“œì—ëŠ” intë¥¼ ë°˜í™˜í•˜ëŠ”Â `mappingCount`Â ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤
  â†’ ë§¤í•‘ì˜ ê°œìˆ˜ê°€ intì˜ ë²”ìœ„ë¥¼ ë„˜ì–´ì„œëŠ” ì´í›„ì˜ ìƒí™©ì„ ëŒ€ì²˜í•  ìˆ˜ ìˆìŒ

## 8.4.3. ì§‘í•©ë·°

- `keySet`Â : ìê¸° ìì‹ ì„ ì§‘í•© ë·°ë¡œ ë°˜í™˜í•˜ëŠ” ìƒˆ ë©”ì„œë“œ

  ```
  // Java code to illustrate the keys() method
  import java.util.*;
  import java.util.concurrent.*;

  public class ConcurrentHashMapDemo {
  	public static void main(String[] args)
  	{

  		// Creating an empty ConcurrentHashMap
  		ConcurrentHashMap<Integer, String> hash_map
  			= new ConcurrentHashMap<Integer, String>();

  		// Mapping string values to int keys
  		hash_map.put(10, "Geeks");
  		hash_map.put(15, "4");
  		hash_map.put(20, "Geeks");
  		hash_map.put(25, "Welcomes");
  		hash_map.put(30, "You");

  		// Displaying the HashMap
  		System.out.println("Initial Mappings are: "
  						+ hash_map);

  		// Using keySet() to get the set view of keys
  		System.out.println("The set is: "
  						+ hash_map.keySet());
  	}
  }
  ```

  ```
  // output
  // Initial Mappings are: {20=Geeks, 25=Welcomes, 10=Geeks, 30=You, 15=4}
  // The set is: [20, 25, 10, 30, 15]

  ```

- Mapì„ ë°”ê¾¸ë©´ ì§‘í•©ë„ ë°”ë€Œê³ , ë°˜ëŒ€ë¡œ ì§‘í•©ì„ ë°”ê¾¸ë©´ ë§µë„ ì˜í–¥ì„ ë°›ìŒ
- `newKeySet`Â : ConcurrentHashMapìœ¼ë¡œ ìœ ì§€ë˜ëŠ” ì§‘í•© ë§Œë“¤ê¸°

  ```
   importÂ java.util.Set;
   importÂ java.util.concurrent.*;

   classÂ ConcurrentHashMapnewKeySetExample1Â {
        publicÂ staticÂ voidÂ main(String[]Â args)
        {
   	 Set<String>Â hashmapÂ =Â ConcurrentHashMap.newKeySet();
   	 hashmap.add("AA");
   	 hashmap.add("BBB");
   	 hashmap.add("CCC");
   	 hashmap.add("DDD");
   	 System.out.println("Â MappingsÂ :Â "+Â hashmap);
        }
   }

  // output
  //  Mappings : [AA, CCC, BBB, DDD]
  ```
