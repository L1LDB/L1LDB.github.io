---
title: ğŸ¦Š 5. Sorting
author: gengminy
date: 2023-11-11 20:00:00 +09:00
categories: [ì½”ë”© ì¸í„°ë·° ëŒ€í•™, 5. Sorting]
tags: [ì½”ë”© ì¸í„°ë·° ëŒ€í•™, ì¶”ê°€ ì§€ì‹, 6ì£¼ì°¨, ë…¸ê²½ë¯¼]
render_with_liquid: false
math: true
---

# 5. Sorting

# ë²„ë¸” ì •ë ¬ (bubble sort)

- í‰ê·  ë° ìµœì•…ì˜ ê²½ìš° `O(n^2)`
- ë©”ëª¨ë¦¬ ì‚¬ìš© `O(1)`

ë°°ì—´ì˜ ì²« ì›ì†Œë¶€í„° ìˆœì°¨ ì‹¤í–‰.

í˜„ì¬ ì›ì†Œê°€ ê·¸ë‹¤ìŒ ì›ì†Œì˜ ê°’ë³´ë‹¤ í¬ë©´ ë‘ ì›ì†Œë¥¼ ë°”ê¾¼ë‹¤.

```java
void bubbleSort(int[] arr) {
  int temp = 0;
	for(int i = 0; i < arr.length - 1; i++) {
		for(int j = 1; j < arr.length - i; j++) {
			if(arr[j] < arr[j - 1]) {
				temp = arr[j - 1];
				arr[j - 1] = arr[j];
				arr[j] = temp;
			}
		}
	}
}
```

# ì„ íƒ ì •ë ¬ (selection sort)

- í‰ê·  ë° ìµœì•…ì˜ ê²½ìš° `O(n^2`
- ë©”ëª¨ë¦¬ ì‚¬ìš© `O(1)`

ë°°ì—´ì„ ì„ í˜• íƒìƒ‰í•˜ë©° ê°€ì¥ ì‘ì€ ì›ì†Œë¥¼ ë°°ì—´ì˜ ë§¨ ì•ìœ¼ë¡œ ë³´ë‚¸ë‹¤.

ê·¸ ë‹¤ìŒì—ëŠ” ë‘ ë²ˆì§¸ ì‘ì€ ì›ì†Œë¥¼ ì°¾ì•„ 2ë²ˆì§¸ ìë¦¬ë¡œ ë³´ë‚¸ë‹¤.

ì´ë¥¼ ëª¨ë“  ì›ì†Œê°€ ì •ë ¬ë  ë•Œê¹Œì§€ ë°˜ë³µí•œë‹¤.

```java
void selectionSort(int[] list) {
    int indexMin, temp;

    for (int i = 0; i < list.length - 1; i++) {
        indexMin = i;
        for (int j = i + 1; j < list.length; j++) {
            if (list[j] < list[indexMin]) {
                indexMin = j;
            }
        }
        temp = list[indexMin];
        list[indexMin] = list[i];
        list[i] = temp;
    }
}
```

# ë³‘í•© ì •ë ¬ (merge sort)

- í‰ê·  ë° ìµœì•…ì˜ ê²½ìš° `O(n log n)`
- ë©”ëª¨ë¦¬ ì‚¬ìš© `ìƒí™©ì— ë”°ë¼ ë‹¤ë¦„, ë˜ëŠ” O(n)`

ë°°ì—´ì„ ì ˆë°˜ì”© ë‚˜ëˆ„ì–´ ê°ê°ì„ ì •ë ¬í•œ ë‹¤ìŒ ì´ ë‘˜ì„ í•©ì³ì„œ ë‹¤ì‹œ ì •ë ¬í•œë‹¤.

ë‚˜ëˆˆ ì ˆë°˜ì„ ì •ë ¬í•  ë•Œë„ ê°™ì€ ì•Œê³ ë¦¬ì¦˜ì´ ì‚¬ìš©ë˜ê³  ê²°êµ­ì—ëŠ” ì›ì†Œ í•œ ê°œì§œë¦¬ ë°°ì—´ ë‘ ê°œë¥¼ ë³‘í•©í•œë‹¤.

**ë³‘í•©**ì„ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ê°€ì¥ ë³µì¡í•˜ë‹¤.

ë³‘í•© ëŒ€ìƒì´ ë˜ëŠ” ë°°ì—´ì˜ ë‘ ë¶€ë¶„ì„ ì„ì‹œ ë°°ì—´ `helper` ì— ë³µì‚¬í•˜ê³ 

ì™¼ìª½ ì ˆë°˜ì˜ ì‹œì‘ ì§€ì  `helperLeft` ì™€ ì˜¤ë¥¸ìª½ ì ˆë°˜ì˜ ì‹œì‘ ì§€ì  `helperRight` ë¥¼ ì¶”ì í•œë‹¤.

ì´í›„ `helper` ë¥¼ ìˆœíšŒí•˜ë©° ë‘ ë°°ì—´ì—ì„œ ë” ì‘ì€ ê°’ì˜ ì›ì†Œë¥¼ êº¼ë‚´ì–´ ì›ë˜ ë°°ì—´ì— ë³µì‚¬í•´ ë„£ëŠ”ë‹¤.

ë‘ ë°°ì—´ ì¤‘ í•œ ë°°ì—´ì— ëŒ€í•œ ìˆœíšŒê°€ ëë‚œ ê²½ìš°,
ë‹¤ë¥¸ ë°°ì—´ì˜ ë‚¨ì€ ë¶€ë¶„ì„ ì›ë˜ ë°°ì—´ì— ë‚¨ê¹€ì—†ì´ ë³µì‚¬í•´ ë„£ê³  ì‘ì—…ì„ ë§ˆì¹œë‹¤.

```java
void mergesort(int[] array) {
	int[] helper = new int[array.length];
	mergesort(array, helper, 0, array.length - 1);
}

void mergesort(int[] array, int[] helper, int low, int high) {
	if (low < high) {
		int middle = (low + high) / 2;
		mergesort(array, helper, low, middle); // ì™¼ìª½ ì ˆë°˜ ì •ë ¬
		mergesort(array, helper, middle + 1, high); //ì˜¤ë¥¸ìª½ ì ˆë°˜ ì •ë ¬
		sort(array, helper, low, middle, high); //ë³‘í•©
	}
}

void merge(int[] array, int[] helper, int low, int middle, int high) {
	/** ì ˆë°˜ì§œë¦¬ ë‘ ë°°ì—´ì„ helper ë°°ì—´ì— ë³µì‚¬í•œë‹¤ */
	for (int i = low; i <= high; i++) {
		helper[i] = array[i];
	}

	int helperLeft = low;
	int helperRight = middle + 1;
	int current = low;

	while (helperLeft <= middle && helperRight <= high) {
		if (helper[helperLeft] <= helper[helperRight]) {
			array[current] = helper[helperLeft];
			helperLeft++;
		} else {
			array[current] = helper[helperRight];
			helperRight++;
		}
		current++;
	}

	int remaining = middle - helperLeft;
	for (int i = 0; i <= remaining; i++) {
		array[current + i] = helper[helperLeft + i];
	}
}
```

ì˜¤ë¥¸ìª½ ì ˆë°˜ì— ëŒ€í•œ ë‚¨ì€ ì›ì†Œë“¤ì„ ì›ë˜ ë°°ì—´ë¡œ ë‹¤ì‹œ ì˜®ê¸°ëŠ” ì½”ë“œê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë°,

ê·¸ ì´ìœ ëŠ” ì˜¤ë¥¸ìª½ ì›ì†Œë“¤ì€ ì´ë¯¸ ì›ë˜ ë°°ì—´ì˜ ê·¸ ìë¦¬ì— ìˆê¸° ë•Œë¬¸ì´ë‹¤.

# í€µ ì •ë ¬ (quick sort)

- í‰ê·  `O(n log n)` | ìµœì•… `O(n^2)`
- ë©”ëª¨ë¦¬ ì‚¬ìš© `O(log n)`

ë¬´ì‘ìœ„ë¡œ ì„ ì •ëœ í•œ ì›ì†Œë¥¼ ì‚¬ìš©í•˜ì—¬ ë°°ì—´ì„ ë¶„í• í•œë‹¤.

ì„ ì •ëœ ì›ì†Œë³´ë‹¤ ì‘ì€ ì›ì†Œë“¤ì€ ì•ìœ¼ë¡œ, í° ì›ì†Œë“¤ì€ ë’¤ë¡œ ë³´ë‚¸ë‹¤.

ë°°ì—´ê³¼ ê·¸ ë¶€ë¶„ ë°°ì—´ì„ ë°˜ë³µì ìœ¼ë¡œ ë¶„í• í•´ ë‚˜ê°€ë©´ ê²°êµ­ ë°°ì—´ì€ ì •ë ¬ëœ ìƒíƒœì— ë„ë‹¬í•œë‹¤.

ë°°ì—´ ë¶„í• ì— ì‚¬ìš©ë˜ëŠ” ì›ì†Œê°€ ì¤‘ê°„ê°’ `medium` ì— ê°€ê¹Œìš´ ê°’ì´ ë˜ë¦¬ë¼ëŠ” ë³´ì¥ì´ ì—†ê¸° ë•Œë¬¸ì—

ìµœì•…ì˜ ê²½ìš° ìˆ˜í–‰ ì‹œê°„ì´ `O(n^2)` ê°€ ë˜ê¸°ë„ í•œë‹¤.

```java
void quickSort(int[] arr, int left, int right) {
	int index = partition(arr, left, right);
	if (left < index - 1) { //ì™¼ìª½ ì ˆë°˜ ì •ë ¬
		quickSort(arr, left, index - 1);
	}
	if (index < right) { //ì˜¤ë¥¸ìª½ ì ˆë°˜ ì •ë ¬
		quickSort(arr, index, right);
	}
}

int partition(int[] arr, int left, int right) {
	int pivot = arr[(left + right) / 2]; // ë¶„í•  ê¸°ì¤€ ì›ì†Œ ì„ ì •
	while (left <= right) {
		while (arr[left] < pivot) left++; //ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì˜®ê²¨ì•¼ í•˜ëŠ” ì›ì†Œ
		while (arr[right] > pivot) right--; //ì˜¤ë¥¸ìª½ì—ì„œ ì™¼ìª½ìœ¼ë¡œ ì˜®ê²¨ì•¼ í•˜ëŠ” ì›ì†Œ

		// ì›ì†Œë¥¼ ìŠ¤ì™‘
		if (left <= right) {
			swap(arr, left, right); // ìŠ¤ì™‘
			left++;
			right--;
		}
	}
	return left;
}
```

# ê¸°ìˆ˜ ì •ë ¬ (radix sort)

- ì‹¤í–‰ ì‹œê°„ `O(kn)`

ê¸°ìˆ˜ ì •ë ¬ì€ ë°ì´í„°ê°€ ì •ìˆ˜ì²˜ëŸ¼ ìœ í•œ ë¹„íŠ¸ë¡œ êµ¬ì„±ë˜ì–´ ìˆëŠ” ê²½ìš° ì‚¬ìš©í•œë‹¤.

ê° ìë¦¿ìˆ˜ë¥¼ ìˆœíšŒì— ë‚˜ê°€ë©° ê° ìë¦¬ì˜ ê°’ì— ë”°ë¼ ê·¸ë£¹ì„ ë‚˜ëˆˆë‹¤.

ê¸°ìˆ˜ ì •ë ¬ì€ `O(kn)` ì˜ ë³µì¡ë„ë¥¼ ì§€ë‹Œë‹¤. (n : ì›ì†Œì˜ ê°œìˆ˜, k : ìë¦¿ìˆ˜ì˜ ê°œìˆ˜)