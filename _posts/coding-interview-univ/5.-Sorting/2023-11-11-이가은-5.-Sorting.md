---
title: ğŸ¢ 5. Sorting
author: gani0325
date: 2023-11-11 20:00:00 +09:00
categories: [ì½”ë”© ì¸í„°ë·° ëŒ€í•™, 5. Sorting]
tags: [ì½”ë”© ì¸í„°ë·° ëŒ€í•™, ì¶”ê°€ ì§€ì‹, 6ì£¼ì°¨, ì´ê°€ì€]
render_with_liquid: false
math: true
---

<h3> ğŸ«§ ë²„ë¸” ì •ë ¬ (Bubble Sort) </h3>

: ë°”ë¡œ ê°€ê¹Œì´ì— ìˆëŠ” ë‘ ìˆ«ìë¼ë¦¬ ë¹„êµë¥¼ í•´ì„œ ë‹¹ì¥
ë” ì‘ì€ ìˆ«ìë¥¼ ì•ìœ¼ë¡œ ë³´ë‚´ì£¼ëŠ” ê²ƒì„ ë°˜ë³µ
: êµ¬í˜„ì€ ì‰½ì§€ë§Œ ê°€ì¥ ë¹„íš¨ìœ¨ì ì¸ ì•Œê³ ë¦¬ì¦˜
: ì‹¤í–‰ ìˆ˜í–‰ì‹œê°„ ê°€ì¥ ëŠë¦¬ë‹¤

: ë²„ë¸” ì •ë ¬ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” N^2

```c
#include <stdio.h>

int main(void) {
	int i, j, temp;
	int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
	for (i = 0; i< 10; i ++) {
		for (j = 0 ; j< 10; j++){
			if (array[j] > array[j+1]) {
				temp = array[j];
				array[j] = array[j+1];
				array[j+1] = temp;
			}
		}
}
	for (i = 0; i<10; i++) {
		printf("%d " , array[i]);
	}
	return 0;
}
// 1 2 3 4 5 6 7 8 9 10
```

<h3> ğŸ«§ ë³‘í•© ì •ë ¬ (Merge Sort) </h3>

: ë¶„í•  ì •ë³µ ë°©ë²•ì„ ì±„íƒí•œ ì•Œê³ ë¦¬ì¦˜
: í€µ ì •ë ¬ê³¼ ë™ì¼í•œ ì‹œê°„ ë³µì¡ë„ ê°€ì§
: í€µ ì •ë ¬ì€ í”¼ë²— ê°’ì— ë”°ë¼ í¸í–¥ë˜ê²Œ ë¶„í• ë¨
: ë³‘í•© ì •ë ¬ì€ ì •í™•íˆ ë°˜ì ˆì”© ë‚˜ëˆˆë‹¤ëŠ” ì ì—ì„œ ìµœì•…ì˜ ê²½ìš°ì—ë„ N\*logN ë³´ì¥
: í”¼ë²— ê°’ì´ ì—†ê³  í•­ìƒ ë°˜ìœ¼ë¡œ ë‚˜ëˆˆë‹¤
: ì´ ë‹¨ê³„ì˜ í¬ê¸°ê°€ logNì´ ë˜ë„ë¡ ë§Œë“¤ì–´ì¤Œ
: í•©ì¹˜ëŠ” ìˆœê°„ì— ì •ë ¬ ìˆ˜í–‰í•˜ê¸°
: ë„ˆë¹„ê°€ Në²ˆ, ë†’ì´ê°€ logN

```c
#include <stdio.h>

int number = 8;
int sorted[8]; // ì •ë ¬ ë°°ì—´ì€ ë°˜ë“œì‹œ ì „ì—­ë³€ìˆ˜ë¡œ ì„ ì–¸

void merge(int a[], int m, int middle, int n) {
	int i = m;
	int j = middle + 1;
	int k = m;
	// ì‘ì€ ìˆœì„œëŒ€ë¡œ ë°°ì—´ì— ì‚½ì…
	while (i <= middle && j <= n)  {
		if (a[i] <= a[j]) {
			sorted[k] = a[i];
			i++;
		}
		else {
			sorted[k] = a[j];
			j ++;
		}
		k++;
	}
	// ë‚¨ì€ ë°ì´í„° ì‚½ì…
	if (i > middle) {
		for (int t =j; t<=n;t++) {
			sorted[k] = a[t];
			k++;
		}
	} else {
		for (int t = i; t <= middle; t++) {
			sorted[k] = a[t];
			k++;
		}
	}
	// ì •ë ¬ëœ ë°°ì—´ ì‚½ì…
	for (int t =m; t <=n; t++) {
		a[t] = sorted[t];
	}
}

void mergeSort(int a[], int m, int n) {
	// í¬ê¸°ê°€ 1 ë³´ë‹¤ í´ ê²½ìš°
	if (m <n) {
		int middle = (m + n) /2;
		mergeSort(a, m, middle);
		mergeSort(a, middle +1, n);
		merge(a, m ,middle, n);
	}
}

int main(void) {
	int array[number] = {7,6,5,8,3,5,9,1};
	mergeSort(array, 0, number-1);
	for (int i=0; i <= number; i ++) {
		printf("%d ", array[i]);
	}
}
// 1 3 5 5 6 7 8 9
```

<h3> ğŸ«§ í€µ ì •ë ¬ (Quick Sort) </h3>

: íŠ¹ì •í•œ ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ í° ìˆ«ìì™€ ì‘ì€ ìˆ«ìë¥¼ ì„œë¡œ êµí™˜í•œ ë’¤ì— ë°°ì—´ì„ ë°˜ìœ¼ë¡œ ë‚˜ëˆˆë‹¤
: í€µ ì •ë ¬ì—ëŠ” ê¸°ì¤€ê°’ì´ ìˆë‹¤ -> í”¼ë²—(Pivot)
: ì²«ë²ˆì§¸ ì›ì†Œë¥¼ í”¼ë²— ê°’ìœ¼ë¡œ ì„¤ì •í•˜ê³  ì‚¬ìš©

: í€µ ì •ë ¬ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” N\*logN

```c
#include <stdio.h>

int number = 10;
int data[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};

void quickSort(int* data, int start, int end) {
	if (start >= end) {		// ì›ì†Œê°€ 1ê°œì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë‘ê¸°
		return;
	}

	int key = start; // í‚¤ëŠ” ì²«ë²ˆì§¸ ì›ì†Œ (pivot)
	int i = start + 1;
	int j = end;
	int temp;

	while (i <= j)  {	// ì—‡ê°ˆë¦´ ë•Œê¹Œì§€ ë°˜ë³µ
		while (i <=end && data[i] <= data[key]) {	// í‚¤ ê°’ë³´ë‹¤ í° ê°’ì„ ë§Œë‚  ë•Œê¹Œì§€
			i++;
		}
		while ( j > start && data[j] >= data[key]) {		// í‚¤ ê°’ë³´ë‹¤ ì‘ì€ ê°’ì„ ë§Œë‚  ë–„ê¹Œì§€
			j--;
		}
		if (i > j) {	// í˜„ì¬ ì—‡ê°ˆë¦° ìƒíƒœë©´ í‚¤ ê°’ê³¼ êµì²´
			temp = data[j];
			data[j] = data[key];
			data[key] = temp;
		}
		else {	// ì—‡ê°ˆë¦¬ì§€ ì•Šì•˜ë‹¤ë©´ iì™€ j êµì²´
			temp = data[j];
			data[j] = data[i];
			data[i] = temp;
		}
	}
	quickSort(data, start, j -1);
	quickSort(data, j+1, end);
}

int main(void) {
	quickSort(data, 0, number - 1);
	for (int i = 0; i< number; i++) {
		printf("%d ", data[i]);
	}
}
// 1 2 3 4 5 6 7 8 9 10
```

<h3> ğŸ«§ ê¸°ìˆ˜ ì •ë ¬ (radix) </h3>

: ì£¼ì–´ì§„ ìˆ˜ ë“¤ê°„ì˜ ë¹„êµë¥¼ í•˜ì§€ ì•Šê³  ë²„í‚·ì„ ì‚¬ìš©í•´ ì •ë ¬í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ, ë‚®ì€ ìë¦¬(1ì˜ ìë¦¬)ì—ì„œ ë†’ì€ ìë¦¬(10^n ìë¦¬) ìˆœìœ¼ë¡œ ë²„í‚·ì— ë„£ëŠ” ë°©ë²•ìœ¼ë¡œ ì •ë ¬í•œë‹¤.

: ì›ì†Œê°’ì´ ëª¨ë‘ k ìë¦¿ìˆ˜ ì´í•˜ì˜ ìì—°ìˆ˜ì¸ íŠ¹ìˆ˜í•œ ê²½ìš°ì— ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì •ë ¬ë°©ë²•ì´ë‹¤.

1. ê°€ì¥ ë‚®ì€ 1ì˜ ìë¦¿ìˆ˜ë§Œ ê°€ì§€ê³  ëª¨ë“  ìˆ˜ë¥¼ ì •ë ¬í•œë‹¤.
2. ê·¸ ë‹¤ìŒìœ¼ë¡œ ë‚®ì€ 10ì˜ ìë¦¿ìˆ˜ë§Œìœ¼ë¡œ ì •ë ¬í•œë‹¤.
3. ì´ ê³¼ì •ì„ ë§ˆì§€ë§‰ ìë¦¿ìˆ˜ê¹Œì§€ ë°˜ë³µí•œë‹¤.

```python
from collections import deque

def radixSort():
    nums = list(map(int, input().split(' ')))
    buckets = [deque() for _ in range(10)]

    max_val = max(nums)
    queue = deque(nums)
    digit = 1 # ìë¦¿ìˆ˜

    while (max_val >= digit): # ê°€ì¥ í° ìˆ˜ì˜ ìë¦¿ìˆ˜ì¼ ë•Œ ê¹Œì§€ë§Œ ì‹¤í–‰
        while queue:
            num = queue.popleft()
            buckets[(num // digit) % 10].append(num) # ê° ìë¦¬ì˜ ìˆ˜(0~9)ì— ë”°ë¼ ë²„í‚·ì— numì„ ë„£ëŠ”ë‹¤.

        # í•´ë‹¹ ìë¦¿ìˆ˜ì—ì„œ ë²„í‚·ì— ë‹¤ ë„£ì—ˆìœ¼ë©´, ë²„í‚·ì— ë‹´ê²¨ìˆëŠ” ìˆœì„œëŒ€ë¡œ êº¼ë‚´ì™€ ì •ë ¬í•œë‹¤.
        for bucket in buckets:
            while bucket:
                queue.append(bucket.popleft())
        print(digit,"ì˜ ìë¦¿ ìˆ˜ ì •ë ¬: ", list(queue))
        digit *= 10 # ìë¦¿ìˆ˜ ì¦ê°€ì‹œí‚¤ê¸°

    print(list(queue))
```
