---
title: 🦊 6. Graphs
author: gengminy
date: 2023-12-03 20:00:00 +09:00
categories: [코딩 인터뷰 대학, 6. Graphs]
tags: [코딩 인터뷰 대학, 추가 지식, 7주차, 노경민]
render_with_liquid: false
math: true
---

# 6. Graphs

# 그래프

트리는 그래프의 한 종류이다.

하지만 모든 그래프가 트리는 아니다.

트리는 사이클이 없는 하나의 연결 그래프이다.

그래프는 단순히 노드와 그 노드를 연결하는 간선(edge)를 하나로 모아놓은 것과 같다.

- 그래프는 방향성이 있을 수도 있고 없을 수도 있다.
- 그래프는 여러 고립된 부분 그래프로 구성될 수 있다. 모든 정점 쌍 간에 경로가 존재하는 그래프는 `연결 그래프` 라고 부른다.
- 그래프에는 사이클이 있을 수도 있고 없을 수도 있다. 사이클이 없는 그래프는 `비순환 그래프` 라고 부른다.

### 인접 리스트

인접 리스트(adjacency list)는 그래프를 표현할 때 사용되는 가장 일반적인 방법이다.

모든 정점을 인접 리스트에 저장한다.

무방향 그래프는 `(a, b)` 간선이 두 번 저장된다.

```java
Class Graph {
	public Node[] nodes;
}

Class Node {
	public String name;
	public Node[] children;
}
```

그래프는 트리와 달리 특정 노드에서 다른 모든 노드로 접근이 가능하지는 않아 Graph 라는 클래스를 사용한다.

배열, 해시테이블과 각 인덱스마다 존재하는 또 다른 리스트를 이용해 인접 리스트를 표현할 수 있다.

```java
0: 1
1: 2
2: 0, 3
3: 2
4: 6
5: 4
6: 5
```

### 인접 행렬

인접 행렬은 NxN 불린 행렬로써 `matrix[i][j] == true` 이면 `i -> j` 간선이 있다는 것이다.

인접 행렬은 조금 효율성이 떨어진다.

어떤 노드에 인접한 노드를 찾기 위해서 모든 노드를 전부 순회해야 할 수 있다.

### 그래프 탐색

깊이 우선 탐색(DFS)는 루트 노드에서 시작해서 다음 분기로 넘거가기 전에 해당 분기를 완벽하게 탐색하는 방법이다.

너비 우선 탐색(BFS)는 루트 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법이다.

DFS는 그래프에서 모든 노드를 방문하고자 할 때 선호되는 편이다.

BFS는 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 일반적이다.

### 깊이 우선 탐색(DFS)

트리의 순회와 그래프 탐색의 가장 큰 차이는 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다는 것이다.

그렇지 않을 경우 무한루프에 빠질 위험이 있다.

```java
void search(Node root) {
	if (root == null) return;
	visit(root);
	root.visited = true;
	for each (Node n in root.adjacent) {
		if (n.visited == false) {
			search(n);
		}
	}
}
```

### 너비 우선 탐색(BFS)

BFS 는 재귀적으로 동작하지 않고 큐를 사용한다.

```java
void search(Node root) {
	Queue queue = new Queue();
	root.marked = true;
	queue.enqueue(root);

	while (!queue.isEmpty()) {
		Node r = queue.dequeue();
		visit(r);
		foreach (Node n in r.adjacent) {
			if (n.marked == false) {
				n.marked = true;
				queue.enqueue(n);
			}
		}
	}
}
```

### 양방향 탐색

양방향 탐색은 출발지와 도착지 사이에 최단 경로를 찾을 때 사용되곤 한다.

기본적으로 출발지와 도착지 두 노드에서 동시에 너비 우선 탐색을 수행한 뒤, 두 탐색 지점이 충돌하는 경우에 경로를 찾는 방식이다.

모든 노드가 적어도 k개의 이웃 노드와 연결되어 있고 s → t로의 최단 거리가 d가 되는 그래프를 생각해보자.

- 전통적인 BFS 에서는 레벨마다 k 개의 노드를 탐색해야 하므로 d번 반복하면 `O(K^d)` 개의 노드를 탐색한다.
- 양방향 탐색을 사용한다면 대략 `d/2` 단계까지 탐색한 후 충돌한다. 따라서 s 와 t 각각에서 방문할 노드는 `k^(d/2)` 개가 될 것이고 전체 방문할 노드는 대략 `2*k^(d/2)` 개가 된다.

즉, 양방향 탐색은 BFS 보다 적어도 `k^(d/2)` 만큼 빠르다.

다른 방식으로 말하면 2배 더 긴 경로까지 찾을 수 있다!
