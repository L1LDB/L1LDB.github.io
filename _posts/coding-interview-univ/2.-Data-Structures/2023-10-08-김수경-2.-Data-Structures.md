---
title: ğŸ£ 2. Data Structures
author: olive-su
date: 2023-10-08 17:00:00 +09:00
categories: [ì½”ë”© ì¸í„°ë·° ëŒ€í•™, 2. Data Structures]
tags: [ì½”ë”© ì¸í„°ë·° ëŒ€í•™, ìë£Œêµ¬ì¡°, 2ì£¼ì°¨, ê¹€ìˆ˜ê²½]
render_with_liquid: false
math: true
---

## ğŸ“š 1. ë°°ì—´ê³¼ ë¬¸ìì—´

### **1. Hash Tables**

- í•´ì‹œí…Œì´ë¸” : íš¨ìœ¨ì ì¸ íƒìƒ‰ì„ ìœ„í•œ ìë£Œêµ¬ì¡°
- í‚¤(key)ë¥¼ ê°’(value)ì— ëŒ€ì‘í•œë‹¤.

- ê°„ë‹¨í•œ í•´ì‹œí…Œì´ë¸” êµ¬í˜„ ë°©ë²•

  - ì—°ê²°ë¦¬ìŠ¤íŠ¸(linked list), í•´ì‹œ ì½”ë“œ í•¨ìˆ˜(hash code function)

- í•´ì‹œí…Œì´ë¸” ë°ì´í„° ì‚½ì… ê³¼ì •
  - í‚¤ì˜ í•´ì‹œ ì½”ë“œë¥¼ ê³„ì‚°í•œë‹¤.
    - _í‚¤ì˜ ìë£Œí˜•ì€ ë³´í†µ `int` í˜¹ì€ `long` ì´ ëœë‹¤._
    - **â¡ï¸ ì´ëŠ” ì„œë¡œ ë‹¤ë¥¸ ë‘ ê°œì˜ í‚¤ê°€ ê°™ì€ í•´ì‹œ ì½”ë“œë¥¼ ê°€ë¦¬í‚¬ ìˆ˜ ìˆìŒì„ ë‚˜íƒ€ëƒ„!**
  - `hash(key) % array_length` ì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ í•´ì‹œ ì½”ë“œë¥¼ ì´ìš©í•´, ë°°ì—´ì˜ ì¸ë±ìŠ¤ë¥¼ êµ¬í•œë‹¤.
  - ë°°ì—´ì˜ ê° ì¸ë±ìŠ¤ì—ëŠ” í‚¤-ê°’ ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ì—°ê²°ë¦¬ìŠ¤íŠ¸ê°€ ì¡´ì¬í•œë‹¤.
    - **ì¶©ëŒì— ëŒ€ë¹„í•˜ì—¬ ë°˜ë“œì‹œ ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¥¼ ì´ìš©í•œë‹¤!**

<br>
<br>

#### **ğŸ¤” í•´ì‹œ ì¶©ëŒ?**

- ì„œë¡œ ë‹¤ë¥¸ ë‘ ê°œì˜ í‚¤ê°€ ê°™ì€ í•´ì‹œ ì½”ë“œë¥¼ ê°€ë¦¬í‚¤ê±°ë‚˜
- ì„œë¡œ ë‹¤ë¥¸ ë‘ ê°œì˜ í•´ì‹œ ì½”ë“œê°€ ê°™ì€ ì¸ë±ìŠ¤ë¥¼ ê°€ë¦¬í‚¤ëŠ” ê²½ìš°

<br>

#### **ğŸ• ìˆ˜í–‰ ì‹œê°„**

- ìµœì•…ì˜ ê²½ìš° : $O(N)$
- _But ì¼ë°˜ì ìœ¼ë¡œ í•´ì‹œì— ëŒ€í•´ ì´ì•¼ê¸°í•  ë•ŒëŠ” ì¶©ëŒì„ ìµœì†Œí™”í•˜ë„ë¡ ì˜ êµ¬í˜„ëœ ê²½ìš°ë¥¼ ê°€ì •í•œë‹¤.
  â¡ï¸ ì´ ê²½ìš°ëŠ” O(1)_

<br>
<br>

---

### **2. ArrayList & Resizable Arraya**

- ArrayList : ë™ì  ê°€ë³€ í¬ê¸° ê¸°ëŠ¥ ë‚´ì¬ ìë£Œí˜•

  - ArrayListëŠ” í•„ìš”ì— ë”°ë¼ í¬ê¸°ë¥¼ ë³€í™”ì‹œí‚¬ ìˆ˜ ìˆìœ¼ë©´ì„œ $O(1)$ ì˜ ì ‘ê·¼ ì‹œê°„ì„ ìœ ì§€í•œë‹¤.
  - ë°°ì—´ì´ ê°€ë“ ì°¨ëŠ” ìˆœê°„, ë°°ì—´ì˜ í¬ê¸°ë¥¼ **2ë°°**ë¡œ ëŠ˜ë¦°ë‹¤.

- í¬ê¸°ë¥¼ 2ë°° ëŠ˜ë¦¬ëŠ” ì—°ì‚°ì€ $O(N)$ ì´ì§€ë§Œ ìì£¼ ë°œìƒí•˜ì§€ ì•Šìœ¼ë¯€ë¡œ, $O(1)$ì´ ëœë‹¤.
  - _ â­ï¸ìƒí™˜ ì…ë ¥ ì‹œê°„ ê°œë… ë„ì…!_

<br>
<br>

<br>
<br>

---

### **3. StringBuilder**

- ë¬¸ìì—´ì„ í•˜ë‚˜ë¡œ ì´ì–´ë¶™ì´ëŠ” ë°©ë²•

<br>

- ex1

```java
String joinWords(String[] words){
  String sentence = "";
 Â for (String w : words) {
 Â  Â sentence = sentence + w;
  }
 Â return sentence;
}
```

- ë¬¸ìì—´ì„ ì´ì–´ë¶™ì¼ ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ ë¬¸ìì—´ì— ë³µì‚¬í•˜ëŠ” ë°©ë²•
  - ì²˜ìŒì—ëŠ” xê°œ, ë‘ ë²ˆì§¸ëŠ” 2xê°œ, ì„¸ ë²ˆì§¸ëŠ” 3xê°œ, në²ˆì§¸ëŠ” nxê°œì˜ ë¬¸ìë¥¼ ë³µì‚¬í•œë‹¤.
- ì‹œê°„ë³µì¡ë„ : $O(xn^2)$

  - $1 + 2 + ... + n = n(n + 1)/2$

<br>

- ex2

```java
String joinWords(String[] words) {
 Â StringBuilder sentence = new StringBuilder();
 Â for (String w : words) {
 Â  Â sentence.append(w);
  }
 Â return sentence.toString;
}
```

- `StringBuilder` ë¥¼ ì´ìš©í•˜ì—¬ ê°€ë³€ í¬ê¸° ë°°ì—´ì„ ì‚¬ìš©í•˜ëŠ” ë°©ë²•
  - í•„ìš”í•œ ê²½ìš°ì—ë§Œ ë¬¸ìì—´ì„ ë³µì‚¬í•˜ê²Œë” í•œë‹¤.

<br>
<br>

---

## ğŸ“š 2. ì—°ê²°ë¦¬ìŠ¤íŠ¸

- ì—°ê²°ë¦¬ìŠ¤íŠ¸ : ì°¨ë¡€ë¡œ ì—°ê²°ëœ ë…¸ë“œë¥¼ í‘œí˜„í•´ì£¼ëŠ” ìë£Œêµ¬ì¡°
- ë‹¨ë°©í–¥ ì—°ê²°ë¦¬ìŠ¤íŠ¸ : ê°œë³„ ë…¸ë“œ â¡ï¸ ë‹¤ìŒ ë…¸ë“œ
- ì–‘ë°©í–¥ ì—°ê²°ë¦¬ìŠ¤íŠ¸ : ê°œë³„ ë…¸ë“œ â¡ï¸ ë‹¤ìŒ ë…¸ë“œ & ì´ì „ ë…¸ë“œ
- â­ï¸ ì‹œì‘ ì§€ì ì—ì„œì˜ ì•„ì´í…œ ì¶”ê°€ ë° ì‚­ì œ ì—°ì‚°ì´ ìƒìˆ˜ ì‹œê°„ ì†Œìš”

<br>

### **1. Creating a Linked List**

- ë‹¨ë°©í–¥ ì—°ê²°ë¦¬ìŠ¤íŠ¸ êµ¬í˜„ ì½”ë“œ

```java
class Node {
 Â Node next = null;
 Â int data;
 Â public Node(int d) {
 Â  Â data = d;
  }
 Â void appendToTail(int d){
 Â  Â Node end = new Node(d);
 Â  Â Node n = this;
 Â  Â while(n.next != null){
 Â  Â  Â n = n.next;
 Â   }
 Â  Â n.next = end;
  }
}

```

- ë‹¨ë°©í–¥ ì—°ê²°ë¦¬ìŠ¤íŠ¸ì—ì„œì˜ ê³ ë ¤ì‚¬í•­ : `head` ê°€ ë°”ë€Œë©´ ì–´ë–»ê²Œ ë˜ëŠ”ê°€?
  - ğŸ‘‰ _`head` ê°€ ë°”ë€Œì—ˆìŒì—ë„ ì–´ë–¤ ê°ì²´ëŠ” `head`ë¥¼ ê³„ì† ê°€ë¦¬í‚¤ê³  ìˆì„ ìˆ˜ë„ ìˆë‹¤._
  - `Node` í´ë˜ìŠ¤ë¥¼ í¬í•¨í•˜ëŠ” `LinkedList` í´ë˜ìŠ¤ë¥¼ ë§Œë“ ë‹¤.(`head Node` ë³€ìˆ˜ì— headë¥¼ ê°€ë¦¬í‚¤ëŠ” ê°’ ì €ì¥)

<br>

### **2. Deleting a Node from a Singly Linked List**

- ì‚­ì œ ë…¸ë“œ : n
  1. `prev.next` ë¥¼ `n.next` ë¡œ ì—°ê²°í•œë‹¤.
  2. (ì–‘ë°©í–¥ ì—°ê²°ë¦¬ìŠ¤íŠ¸ì¼ ê²½ìš°) `n.next.prev` ë¥¼ `n.prev` ë¡œ ì—°ê²°í•œë‹¤.
- âš ï¸ ë©”ëª¨ë¦¬ ê´€ë¦¬ê°€ í•„ìš”í•œ ì–¸ì–´ë¥¼ ì‚¬ìš©í•´ êµ¬í˜„í•˜ëŠ” ê²½ìš°ì—ëŠ” ì‚­ì œí•œ ë…¸ë“œì— í• ë‹¹ë˜ì—ˆë˜ ë©”ëª¨ë¦¬ê°€ ì œëŒ€ë¡œ ë°˜í™˜ë˜ì—ˆëŠ”ì§€ í™•ì¸ í•„ìš”!
- ë…¸ë“œ ì‚­ì œ ì½”ë“œ

```java
Node deleteNode(Node head, int d) {
 Â Node n = head;
 Â if (n.data == d) {
 Â  Â return head.next;
  }

 Â while (n.next != null) {
 Â  Â if (n.next.data == d) {
 Â  Â  Â n.next = n.next.next;
 Â  Â  Â return head;
 Â   }
 Â  Â n = n.next;
  }
 Â return head;
}

```

<br>

### **3. The "Runner" Technique**

- Runner : ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¥¼ ìˆœíšŒí•  ë•Œ ë‘ ê°œì˜ í¬ì¸í„°ë¥¼ ë™ì‹œì— ì‚¬ìš©í•œë‹¤.
- í•œ í¬ì¸í„°ê°€ ë‹¤ë¥¸ í¬ì¸í„°ë³´ë‹¤ ì•ì„œë„ë¡ í•˜ê³  í¬ì¸í„°ë¥¼ ì›€ì§ì¼ ë•Œ ì§€ì •ëœ ê°œìˆ˜ í˜¹ì€ ì—¬ëŸ¬ ë…¸ë“œë¥¼ í•œë²ˆì— ì›€ì§ì¼ ìˆ˜ ìˆë„ë¡ ì„¤ì •í•œë‹¤.

<br>

### **4. Recursive Problems**

- ì—°ê²°ë¦¬ìŠ¤íŠ¸ ë¬¸ì œ â‰’ ì¬ê·€ í˜¸ì¶œ
- âš ï¸ ì¬ê·€(recursive) ì•Œê³ ë¦¬ì¦˜ì€ ì ì–´ë„ $O(n)$ì˜ ê³µê°„ ë³µì¡ë„ë¥¼ ê°–ëŠ”ë‹¤!

<br>
<br>

---

## ğŸ“Â 1. **[CS50 2020 - Lecture 2 - Arrays](https://youtu.be/tI_tIZFyKBw?t=3825)**

```java
int scores[3];
```

- a chunk of memory
- ì—°ì†ëœ ê°’ìœ¼ë¡œ ì…ë ¥ëœë‹¤.

<br>

```java
int scores[3];
scores[0] = 72;
scores[1] = 73;
scores[2] = 33;
```

ğŸ’¡ ì¼ì¢…ì˜ í”„ë¡œê·¸ë˜ë° ê´€ë¡€ë¡œ 0ë¶€í„° ì¸ë±ìŠ¤ë¥¼ ì‹œì‘í•œë‹¤.

- ë°°ì—´ì„ ì„ ì–¸í•  ë•Œ "[3]"ê³¼ ê°™ì€ í‘œí˜„ì„ ì“°ëŠ” ë°, ì´ëŠ” ì´ ê°’ì˜ ìˆ˜ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.
- ë°°ì—´ì— ìƒ‰ì¸ì„ ìƒì„±í•  ë•Œ, í•´ë‹¹ ë©”ëª¨ë¦¬ ì²­í¬ì˜ íŠ¹ì • ìœ„ì¹˜ë¡œ ì´ë™í•˜ë©´ ìœ ì‚¬í•œ ìˆ«ìë¥¼ ì‚¬ìš©í•œë‹¤.
  - â¡ï¸ ìƒëŒ€ì ì¸ ìœ„ì¹˜ë¥¼ ì°¸ì¡°(ì²« ë²ˆì§¸, ë‘ ë²ˆì§¸, ì„¸ ë²ˆì§¸)

<br>
<br>

---

## ğŸ“Â 2. **[Arrays | Coursera](https://www.coursera.org/lecture/data-structures/arrays-OsBSF?authMode=signup&redirectTo=%2Flecture%2Fdata-structures%2Farrays-OsBSF)**

### 1. Arrays

- Array : ë©”ëª¨ë¦¬ì˜ ì—°ì†ì ì¸ ì˜ì—­

  - í•˜ë‚˜ì˜ ë©”ëª¨ë¦¬ ì²­í¬

- Key Point : random access

  - ë°°ì—´ì˜ ì–´ëŠ íŠ¹ì •í•œ ìš”ì†Œì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.
  - "Constant time access to read, Constant time access to wright"

- ê° ì›ì†Œì˜ ì˜ì—­ì€ ëª¨ë‘ ê°™ì€ ì‚¬ì´ì¦ˆë¡œ í• ë‹¹ì´ ëœë‹¤.
- ì›ì†Œì˜ ì£¼ì†Œë¥¼ ë„ì¶œí•˜ëŠ” ìˆ˜ì‹

$$
arrayAddr + elemSize * (i - firstIndex)
$$

<br>
<br>

---

### 2. Multi-Dimensional Arrays

![Image](/assets/img/olive-su/coding-interview-univ/ch2-img1.png){: width="700" height="400" }

- `row - column` ìŒìœ¼ë¡œ í‘œí˜„ì´ ê°€ëŠ¥í•˜ë‹¤.

- ì ‘ê·¼ ë°©ë²•
  - ì ‘ê·¼í•˜ë ¤ëŠ” ìš”ì†Œ ì´ì „ì˜ í–‰ë“¤ì„ ê±´ë„ˆë›´ë‹¤.
  - í•œ í–‰ì˜ ëª¨ë“  ìš”ì†Œë“¤ì˜ ê°œìˆ˜ë¥¼ ê³±í•œë‹¤.

$$
elemSize _ ((3-1) _ 6 + (4-1))
$$

<br>

#### 2-1. row-major ordering & column-major ordering

![Image](/assets/img/olive-su/coding-interview-univ/ch2-img2.png)

_(ì¢Œ : row-major ordering | ìš° : column-major ordering)_

- ë©”ëª¨ë¦¬ì—ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë°°ì¹˜ëœë‹¤.

- row-major ordering : ì›ì†Œê°€ í–‰ì— ë”°ë¼ ì—°ì†ì ìœ¼ë¡œ ë°°ì¹˜ë˜ëŠ” ë°©ì‹
- column-major ordering : ì›ì†Œê°€ ì—´ì— ë”°ë¼ ì—°ì†ì ìœ¼ë¡œ ë°°ì¹˜ë˜ëŠ” ë°©ì‹
  - _ì–¸ì–´ì™€ ì»´íŒŒì¼ëŸ¬ë§ˆë‹¤ ë‹¤ë¥´ë‹¤._

<br>
<br>

---

### 3. Times for Common Operations

![Image](/assets/img/olive-su/coding-interview-univ/ch2-img3.png){: width="500" height="250" }

- beginning : nê°œ ìš”ì†Œ ì¬ì •ë ¬
- end : ì „ì²´ ì›ì†Œì˜ ê°œìˆ˜ë§Œ ì—…ë°ì´íŠ¸í•˜ë©´ ë¨
- middle : n/2ê°œ ìš”ì†Œ ì¬ì •ë ¬

- â­ **í•µì‹¬ : ì›ì†Œì— ì ‘ê·¼/ì½ê¸°/ì“°ê¸°ì— ì¼ì •í•œ ì‹œê°„ì´ ì†Œìš”ëœë‹¤.**

<br>
<br>

---

### âœ¨ Summary

- Array : contiguous area of memory consisting of equal-size elements indexed by contiguous integers.
- Constant-time access to any element.
- Constant time to add/remove at the end.
- Linear time to add/remove at an arbitrary location.

<br>
<br>

---

## ğŸ“Â 3. **[Dynamic Arrays | Coursera](https://www.coursera.org/lecture/data-structures/dynamic-arrays-EwbnV)**

### 1. Problem

- ë¬¸ì œ ì‚¬í•­ : ë°°ì—´ì€ ì •ì ì´ë‹¤.

  - í•´ê²° : ëŸ°íƒ€ì„ì‹œì— í¬ê¸°ê°€ ê²°ì •ë˜ëŠ” ë™ì  ê°€ë³€ ë°°ì—´ì„ ì‚¬ìš©í•œë‹¤.

<br>

- Solution : dynamic arrays

  - ë™ì ìœ¼ë¡œ í• ë‹¹ë˜ëŠ” ë°°ì—´ì˜ í¬ì¸í„°ë¥¼ ì €ì¥í•˜ê³  ìƒˆë¡œ í• ë‹¹ì´ í•„ìš”í•  ë•Œì—ëŠ” í•´ë‹¹ í¬ì¸í„°ë¥¼ ë°”ê¾¼ë‹¤.
  - ì´ì „ ë°°ì—´ì˜ ì›ì†Œë“¤ì„ ë³µì‚¬í•˜ê³  ì´ì „ ë°°ì—´ì˜ ìœ„ì¹˜ë¥¼ ê°€ë¦¬í‚¤ë˜ í¬ì¸í„° ê°’ì„ ìƒˆë¡œìš´ ë°°ì—´ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„° ê°’ìœ¼ë¡œ ë°”ê¾¼ë‹¤.

<br>

- Operations

  - `get(i)` : ië²ˆì§¸ì— ìœ„ì¹˜í•œ ì›ì†Œ
  - `set(i, val)` : ië²ˆì§¸ ìœ„ì¹˜ì— val ì‚½ì…
  - `pushback(val)` : valì„ ë§ˆì§€ë§‰ ìœ„ì¹˜ì— ì‚½ì…
  - `remove(i)` : ië²ˆì§¸ì— ìœ„ì¹˜í•œ ì›ì†Œ ì œê±°
  - `size(i)` : ì „ì²´ ì›ì†Œ ê°œìˆ˜

<br>

- size :vs: capacity

![Image](/assets/img/olive-su/coding-interview-univ/ch2-img4.png){: width="600" }

- ë°°ì—´ì´ ë‹¤ ì°¼ì„ ê²½ìš°
  1. ì›ë˜ í¬ê¸°ì˜ ë‘ ë°°ë§Œí¼ ìƒˆë¡œìš´ ë°°ì—´ì„ ë§Œë“ ë‹¤.
  2. ê¸°ì¡´ ì›ì†Œë“¤ì„ ë³µì‚¬í•˜ì—¬ ë„£ëŠ”ë‹¤.
  3. ì›ë˜ì˜ í¬ì¸í„° ìœ„ì¹˜ë¥¼ ìƒˆ ë°°ì—´ì˜ í¬ì¸í„° ìœ„ì¹˜ë¡œ ë°”ê¾¼ë‹¤.

<br>
<br>

---

### 2. Common Implementations

- C++ : vector
- Java : ArrayList
- Python : list
  - pythonì—ì„œëŠ” ì •ì  ë°°ì—´ì„ í‘œí˜„í•  ìˆ˜ ì—†ë‹¤.

<br>
<br>

---

### 3. Runtimes

- `get(i)` : $O(1)$
- `set(i, val)` : $O(1)$
- `pushback(val)` : $O(n)$
- `remove(i)` : $O(n)$
- `size()` : $O(1)$

<br>
<br>

---

### âœ¨ Summary

- Unlike static arrays, dynamic arrays can be resized.
- Appending a new element to a dynamic array is often constant time, but can take $O(n)$.
- Some space is wasted.

<br>
<br>

---

## ğŸ“ 4. Implementation Arrays

#### **Implement a vector (mutable array with automatic resizing)**

- [x] Practice coding using arrays and pointers, and pointer math to jump to an index instead of using indexing.
- [x] New raw data array with allocated memory
  - can allocate int array under the hood, just not use its features
  - start with 16, or if starting number is greater, use power of 2 - 16, 32, 64, 128
- [x] size() - number of items
- [x] capacity() - number of items it can hold
- [x] is_empty()
- [x] at(index) - returns item at given index, blows up if index out of bounds
- [x] push(item)
- [x] insert(index, item) - inserts item at index, shifts that index's value and trailing elements to the right
- [x] prepend(item) - can use insert above at index 0
- [x] pop() - remove from end, return value
- [x] delete(index) - delete item at index, shifting all trailing elements left
- [x] remove(item) - looks for value and removes index holding it (even if in multiple places)
- [x] find(item) - looks for value and returns first index with that value, -1 if not found
- [x] resize(new_capacity) // private function
  - when you reach capacity, resize to double the size
  - when popping an item, if size is 1/4 of capacity, resize to half
- [ ] Time
  - O(1) to add/remove at end (amortized for allocations for more space), index, or update
  - O(n) to insert/remove elsewhere
- [ ] Space
  - contiguous in memory, so proximity helps performance
  - space needed = (array capacity, which is >= n) \* size of item, but even if 2n, still O(n)

<br>
<br>

---

### **ğŸ¤” ì„¤ê³„ ê³ ë ¤ì‚¬í•­**

- ìë£Œí˜•ì€ `int`ë¡œ í•œì •í•œë‹¤.
- ë§¨ ì²˜ìŒ ìƒì„±ìë¥¼ í†µí•´ ì´ˆê¸°í™” ë²¡í„°ê°€ ìƒì„±ëœë‹¤.

> New raw data array with allocated memory
>
> - can allocate int array under the hood, just not use its features
> - start with 16, or if starting number is greater, use power of 2 - 16, 32, 64, 128

<br>

- javaì˜ `ArrayList` ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  ì •ì  ë°°ì—´ í˜•íƒœë¡œ ë™ì  ê°€ë³€ ë°°ì—´ì„ êµ¬í˜„í•œë‹¤.
- ê¸°ë³¸ ì›ì†Œì˜ ê°œìˆ˜ëŠ” 16ë¶€í„° ì‹œì‘í•œë‹¤.
- ê·¸ ë°–ì˜ ë””í…Œì¼í•œ êµ¬í˜„ ì‚¬í•­ë“¤ì€ ë¬¸ì„œí™” ì£¼ì„ìœ¼ë¡œ í•¨ìˆ˜ ì •ì˜ë¬¸ ìœ„ì— ê¸°ë¡í•œë‹¤.

<br>

- âš ï¸ ì£¼ì˜ì‚¬í•­
  - ì‚½ì… ì‹œ, ë°°ì—´ í™•ì¥ ê³ ë ¤
  - ì‚­ì œ ì‹œ, ë°°ì—´ ì¶•ì†Œ ê³ ë ¤

```java
public class Arrays {
    private int[] vector;
    private int elemCnt = 0;

    public Arrays(){
        vector = new int[16];
    }

    public int size(){
        return elemCnt;
    }

    public int capacity(){
        return vector.length - size();
    }

    /**
     * @return ë¹„ì–´ìˆìœ¼ë©´ True(1), ìš”ì†Œê°€ ìˆìœ¼ë©´ False(0)
     */
    public boolean is_empty(){
        return elemCnt == 0;
    }

    /**
     * ì…ë ¥ ì¸ë±ìŠ¤ê°€ ë²”ìœ„ ë°–ì´ë©´ 'IndexOutOfBoundsException' ì—ëŸ¬ ë°œìƒ
     */
    public int at(int index){
        if (index >= 0 || index < size()){
            return vector[index];
        } else {
            throw new IndexOutOfBoundsException();
        }
    }

    public void push(int item){
        if (capacity() == 0){
            resize(size() * 2);
        }
        vector[elemCnt++] = item;
    }

    /**
     * ì…ë ¥ ì¸ë±ìŠ¤ê°€ ë²”ìœ„ ë°–ì´ë©´ 'IndexOutOfBoundsException' ì—ëŸ¬ ë°œìƒ
     */
    public void insert(int index, int item){
        if (index < size()){
            int[] newVector = new int[vector.length];

            if (capacity() == 0) {
                resize(size() * 2);
            }

            for (int i = 0; i < index; i++) {
                newVector[i] = vector[i];
            }
            newVector[index] = item;
            for (int i = index + 1; i < size() + 1; i++) {
                newVector[i] = vector[i - 1];
            }

            elemCnt++;
            vector = newVector;
        } else {
            throw new IndexOutOfBoundsException();
        }
    }

    public void prepend(int item){
        if (capacity() == 0){
            resize(size() * 2);
        }

        int[] newVector = new int[vector.length];

        for (int i = 0; i < size(); i++){
            newVector[i + 1] = vector[i];
        }
        newVector[0] = item;

        elemCnt++;
        vector = newVector;
    }

    /**
     * ë²¡í„°ê°€ ë¹„ì—ˆì„ ê²½ìš° 'NullPointerException' ì—ëŸ¬ ë°œìƒ
     */
    public int pop(){
        int rst;

        if (is_empty()){
            throw new NullPointerException();
        }

        rst = vector[elemCnt - 1];
        vector[elemCnt--] = 0;

        if (size() / 4 == vector.length){
            resize(size() / 4);
        }

        return rst;
    }

    /**
     * ì…ë ¥ ì¸ë±ìŠ¤ê°€ ë²”ìœ„ ë°–ì´ë©´ 'IndexOutOfBoundsException' ì—ëŸ¬ ë°œìƒ
     */
    public void delete(int index){
        if (index < size()){
            for (int i = index; i < size(); i++){
                vector[i] = vector[i + 1];
            }

            elemCnt--;

            if (size() / 4 == vector.length){
                resize(size() / 4);
            }
        } else {
            throw new IndexOutOfBoundsException();
        }
    }

    /**
     * itemì´ ì¡´ì¬í•˜ëŠ” ëª¨ë“  ì¸ë±ìŠ¤ ìœ„ì¹˜ì˜ ì›ì†Œ ì‚­ì œ
     */
    public void remove(int item){
        for (int i = 0; i < size(); i++) {
            if (vector[i] == item){
                delete(i);
            }
        }
    }

    /**
     * itemì´ ë²¡í„° ë‚´ì— ì—†ìœ¼ë©´ -1 ë¦¬í„´
     */
    public int find(int item){
        for (int i = 0; i < size(); i++) {
            return i;
        }
        return -1;
    }

    private void resize(int new_capacity){
        int[] newVector = new int[new_capacity];

        for (int i = 0; i < size(); i++) {
            newVector[i] = vector[i];
        }
        vector = newVector;
    }

    // test
    public static void main(String[] args) {
        Arrays tmpVector = new Arrays();
        System.out.println("test 1:" + tmpVector.size());
        System.out.println("test 2:" + tmpVector.capacity());
        System.out.println("test 3:" + tmpVector.is_empty());
        tmpVector.push(3);
        tmpVector.push(4);
        System.out.println("test 4:" + tmpVector.at(0)); // 3
        System.out.println("test 5:" + tmpVector.at(1)); // 4
        tmpVector.insert(0, 2);
        tmpVector.prepend(1);
        System.out.println("test 6:" + java.util.Arrays.toString(tmpVector.vector)); // [1, 2, 3, 4, ...]
        System.out.println("test 7:" + tmpVector.pop());
        tmpVector.delete(0);
        tmpVector.remove(2);
        System.out.println("test 8:" + tmpVector.find(3)); // 0
    }
}

```

<br>
<br>

---

## ğŸ“Â 4. Implementation LinkedList

- Implement (I did with tail pointer & without):
  - [x] size() - returns number of data elements in list
  - [x] empty() - bool returns true if empty
  - [x] value_at(index) - returns the value of the nth item (starting at 0 for first)
  - [x] push_front(value) - adds an item to the front of the list
  - [x] pop_front() - remove front item and return its value
  - [x] push_back(value) - adds an item at the end
  - [x] pop_back() - removes end item and returns its value
  - [x] front() - get value of front item
  - [x] back() - get value of end item
  - [x] insert(index, value) - insert value at index, so current item at that index is pointed to by new item at index
  - [x] erase(index) - removes node at given index
  - [x] value_n_from_end(n) - returns the value of the node at nth position from the end of the list
  - [x] reverse() - reverses the list
  - [x] remove_value(value) - removes the first item in the list with this value
  - [ ] Doubly-linked List
    - [Description (video)](https://www.coursera.org/lecture/data-structures/doubly-linked-lists-jpGKD)
    - No need to implement

<br>
<br>

---

### **ğŸ¤” ì„¤ê³„ ê³ ë ¤ì‚¬í•­**

- ìë£Œí˜•ì€ `int`ë¡œ í•œì •í•œë‹¤.
- ë§¨ ì²˜ìŒ ìƒì„±ìë¥¼ í†µí•´ ì´ˆê¸°í™” ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ê°€ ìƒì„±ëœë‹¤.

```java
import java.util.*;

public class ImplLinkedList {
 Â  Â private LinkedList<Integer> LinkedList;

 Â  Â public ImplLinkedList() {
 Â  Â  Â  Â LinkedList = new LinkedList<>();
 Â   }

 Â  Â public int size() {
 Â  Â  Â  Â return LinkedList.size();
 Â   }

 Â  Â public boolean empty() {
 Â  Â  Â  Â return LinkedList.size() == 0;
 Â   }

 Â  Â /**
 Â  Â  * ì…ë ¥ ì¸ë±ìŠ¤ê°€ ë²”ìœ„ ë°–ì´ë©´ 'IndexOutOfBoundsException' ì—ëŸ¬ ë°œìƒ
 Â  Â  */
 Â  Â public int value_at(int index) {
 Â  Â  Â  Â if (index >= 0 || index < size()){
 Â  Â  Â  Â  Â  Â return LinkedList.get(index);
 Â  Â  Â   } else {
 Â  Â  Â  Â  Â  Â throw new IndexOutOfBoundsException();
 Â  Â  Â   }
 Â   }

 Â  Â public void push_front(int value) {
 Â  Â  Â  Â LinkedList<Integer> newLinkedList = new LinkedList<>();
 Â  Â  Â  Â newLinkedList.push(value);

 Â  Â  Â  Â for (int e : LinkedList)
 Â  Â  Â  Â  Â  Â newLinkedList.push(e);

 Â  Â  Â  Â LinkedList = newLinkedList;
 Â   }

 Â  Â /**
 Â  Â  * ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì—ˆì„ ê²½ìš° 'NullPointerException' ì—ëŸ¬ ë°œìƒ
 Â  Â  */
 Â  Â public int pop_front() {
 Â  Â  Â  Â if (empty()){
 Â  Â  Â  Â  Â  Â throw new NullPointerException();
 Â  Â  Â   }
 Â  Â  Â  Â return LinkedList.pollFirst();
 Â   }

 Â  Â public void push_back(int value){
 Â  Â  Â  Â LinkedList.push(value);
 Â   }

 Â  Â /**
 Â  Â  * ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì—ˆì„ ê²½ìš° 'NullPointerException' ì—ëŸ¬ ë°œìƒ
 Â  Â  */
 Â  Â public int pop_back() {
 Â  Â  Â  Â if (empty()){
 Â  Â  Â  Â  Â  Â throw new NullPointerException();
 Â  Â  Â   }
 Â  Â  Â  Â return LinkedList.poll();
 Â   }

 Â  Â /**
 Â  Â  * ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì—ˆì„ ê²½ìš° 'NullPointerException' ì—ëŸ¬ ë°œìƒ
 Â  Â  */
 Â  Â public int front() {
 Â  Â  Â  Â if (empty()){
 Â  Â  Â  Â  Â  Â throw new NullPointerException();
 Â  Â  Â   }
 Â  Â  Â  Â return LinkedList.peekFirst();
 Â   }

 Â  Â /**
 Â  Â  * ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì—ˆì„ ê²½ìš° 'NullPointerException' ì—ëŸ¬ ë°œìƒ
 Â  Â  */
 Â  Â public int back() {
 Â  Â  Â  Â if (empty()){
 Â  Â  Â  Â  Â  Â throw new NullPointerException();
 Â  Â  Â   }
 Â  Â  Â  Â return LinkedList.peek();
 Â   }

 Â  Â /**
 Â  Â  * ì…ë ¥ ì¸ë±ìŠ¤ê°€ ë²”ìœ„ ë°–ì´ë©´ 'IndexOutOfBoundsException' ì—ëŸ¬ ë°œìƒ
 Â  Â  */
 Â  Â public void insert(int index, int value) {
 Â  Â  Â  Â if (index >= 0 || index < size()){
 Â  Â  Â  Â  Â  Â LinkedList<> newLinkedList = new LinkedList<Integer>();

 Â  Â  Â  Â  Â  Â for (int i = 0; i < index; i++) {
 Â  Â  Â  Â  Â  Â  Â  Â newLinkedList.push(LinkedList.get(i));
 Â  Â  Â  Â  Â   }

 Â  Â  Â  Â  Â  Â newLinkedList.add(index, value);

 Â  Â  Â  Â  Â  Â for (int i = index; i <= size(); i++) {
 Â  Â  Â  Â  Â  Â  Â  Â newLinkedList.push(LinkedList.get(i));
 Â  Â  Â  Â  Â   }
 Â  Â  Â  Â  Â  Â LinkedList = newLinkedList;

 Â  Â  Â   } else {
 Â  Â  Â  Â  Â  Â throw new IndexOutOfBoundsException();
 Â  Â  Â   }
 Â   }

 Â  Â /**
 Â  Â  * ì…ë ¥ ì¸ë±ìŠ¤ê°€ ë²”ìœ„ ë°–ì´ë©´ 'IndexOutOfBoundsException' ì—ëŸ¬ ë°œìƒ
 Â  Â  */
 Â  Â public void erase(int index) {
 Â  Â  Â  Â if (index >= 0 || index < size()){
 Â  Â  Â  Â  Â  Â LinkedList.remove(index);
 Â  Â  Â   } else {
 Â  Â  Â  Â  Â  Â throw new IndexOutOfBoundsException();
 Â  Â  Â   }
 Â   }

 Â  Â /**
 Â  Â  * 0ë²ˆì§¸ ìš”ì†Œë¶€í„° ê°€ëŠ¥ -> 0ë²ˆì§¸ ìš”ì†Œ : ë§ˆì§€ë§‰ ìš”ì†Œ
 Â  Â  * ì…ë ¥ ì¸ë±ìŠ¤ê°€ ë²”ìœ„ ë°–ì´ë©´ 'IndexOutOfBoundsException' ì—ëŸ¬ ë°œìƒ
 Â  Â  */
 Â  Â public int value_v_from_end(int n) {
 Â  Â  Â  Â if (n >= 0 || n < size()){
 Â  Â  Â  Â  Â  Â return LinkedList.get(size() - 1 - n);
 Â  Â  Â   } else {
 Â  Â  Â  Â  Â  Â throw new IndexOutOfBoundsException();
 Â  Â  Â   }
 Â   }

 Â  Â public LinkedList<Integer> reverse() {
 Â  Â  Â  Â LinkedList<Integer> newLinkedList = new LinkedList<>();

 Â  Â  Â  Â for (int e : LinkedList)
 Â  Â  Â  Â  Â  Â newLinkedList.add(0, e);

 Â  Â  Â  Â return newLinkedList;
 Â   }

 Â  Â /**
 Â  Â  * ê°’ì´ ì—†ìœ¼ë©´ ì•„ë¬´ê²ƒë„ ìˆ˜í–‰í•˜ì§€ ì•ŠìŒ
 Â  Â  * ë‹¤ì¤‘ ê°’ ì¡´ì¬ ì‹œ, ë§¨ ì• ìš”ì†Œ ì œê±°
 Â  Â  */
 Â  Â public void remove_value(int value) {
 Â  Â  Â  Â for (int e : LinkedList){
 Â  Â  Â  Â  Â  Â if (e == value)
 Â  Â  Â  Â  Â  Â  Â  Â LinkedList.remove(e);
 Â  Â  Â   }
 Â   }
}
```
