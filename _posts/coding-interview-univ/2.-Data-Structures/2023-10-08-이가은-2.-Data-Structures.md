---
title: ğŸ¢ 2. Data Structures
author: gani0325
date: 2023-10-08 20:00:00 +09:00
categories: [ì½”ë”© ì¸í„°ë·° ëŒ€í•™, 2. Data Structures]
tags: [ì½”ë”© ì¸í„°ë·° ëŒ€í•™, ì¶”ê°€ ì§€ì‹, 2ì£¼ì°¨, ì´ê°€ì€]
render_with_liquid: false
math: true
---


<h2>ğŸ’¡ ìë£Œêµ¬ì¡° </h2>

- ë°°ì—´

- ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸

- ìŠ¤íƒ

- í

- í•´ì‹œ í…Œì´ë¸”

----

<h3> ğŸ«§ ë°°ì—´ê³¼ ë¬¸ìì—´ </h3>

**â¤ï¸ í•´ì‹œí…Œì´ë¸” (hash table)**

: íš¨ìœ¨ì ì¸ íƒìƒ‰ì„ ìœ„í•œ ìë£Œêµ¬ì¡°ë¡œì„œ, keyë¥¼ value ì— ëŒ€ì‘ì‹œí‚´

: ìµœì•…ì˜ ê²½ìš° O(n)      // nì€ í‚¤ì˜ ê°œìˆ˜

: ìµœì„ ì˜ ê²½ìš° O(1)

**1) í‚¤ì˜ í•´ì‹œ ì½”ë“œ ê³„ì‚°**

- í‚¤ì˜ ìë£Œí˜•ì€ ë³´í†µ int or long
- í‚¤ì˜ ê°œìˆ˜ ë¬´í•œ (int ëŠ” ìœ í•œ)

**2) hash(key) % array_length ë°©ì‹ìœ¼ë¡œ í•´ì‹œ ì½”ë“œ ì´ìš©í•´ ë°°ì—´ì˜ ì¸ë±ìŠ¤ êµ¬í•¨**

- ì„œë¡œ ë‹¤ë¥¸ ë‘ ê°œì˜ í•´ì‹œ ì½”ë“œê°€ ê°™ì€ ì¸ë±ìŠ¤ ê°€ë¦¬í‚¬ ìˆ˜ ìˆìŒ

**3) ë°°ì—´ì˜ ê° ì¸ë±ìŠ¤ì—ëŠ” í‚¤ì™€ ê°’ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ì—°ê²°ë¦¬ìŠ¤íŠ¸ ì¡´ì¬**

- í‚¤ì™€ ê°’ì„ í•´ë‹¹ ì¸ë±ìŠ¤ì— ì €ì¥ (ë°˜ë“œì‹œ ì—°ê²°ë¦¬ìŠ¤íŠ¸ ì´ìš©!)
- **ğŸ’¥ ì¶©ëŒ** : ì„œë¡œ ë‹¤ë¥¸ ë‘ ê°œì˜ í‚¤ê°€ ê°™ì€ ì½”ë“œë¥¼ ê°€ë¦¬í‚¤ê±°ë‚˜, ì„œë¡œ ë‹¤ë¥¸ ë‘ ê°œì˜ í•´ì‹œ ì½”ë“œê°€ ê°™ì€ ì¸ë±ìŠ¤ë¥¼ ê°€ë¦¬í‚¤ëŠ” ê²½ìš°

â‡’ í‚¤ì— ìƒì‘í•˜ê¸° ìœ„í•´ì„œ ìœ„ë¥¼ ë°˜ë³µ!

â‡’ ì£¼ì–´ì§„ í‚¤ë¡œë¶€í„° í•´ì‹œ ì½”ë“œë¥¼ ê³„ì‚°, í•´ì‹œ ì½”ë“œë¥¼ ì´ìš©í•´ ì¸ë±ìŠ¤ ê³„ì‚°, í•´ë‹¹ í‚¤ì— ìƒì‘í•˜ëŠ” ê°’ì„ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì—ì„œ íƒìƒ‰

>>
    â• ê· í˜• ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ (balanced binary search tree) 
    : íƒìƒ‰ ì‹œê°„ì€ O(logN)
    : í¬ê¸°ê°€ í° ë°°ì—´ì„ ë¯¸ë¦¬ í• ë‹¹í•´ ë†“ì§€ ì•Šì•„ë„ ë˜ê¸° ë•Œë¬¸ì— ì ì€ ê³µê°„ ì‚¬ìš© ê°€ëŠ¥
    : í‚¤ì˜ ì§‘í•©ì„ íŠ¹ì • ìˆœì„œëŒ€ë¡œ ì ‘ê·¼ ê°€ëŠ¥
>>

**â¤ï¸ ArrayList ì™€ ê°€ë³€ í¬ê¸° ë°°ì—´**

- ArrayList
    - ë™ì  ê°€ë³€ í¬ê¸° ê¸°ëŠ¥ ë‚´ì¬ì˜ ë°°ì—´ì¼ ë•Œ ì‚¬ìš©
    - í•„ìš”ì— ë”°ë¼ í¬ê¸°ë¥¼ ë³€í™” ê°€ëŠ¥
    - O(1)ì˜ ì ‘ê·¼ ì‹œê°„ì„ ìœ ì§€
    - ë°°ì—´ì´ ê°€ë“ ì°¨ë©´, ë°°ì—´ì˜ í¬ê¸°ë¥¼ ë‘ ë°°ë¡œ ëŠ˜ë¦¼
        - O(n)ìœ¼ë¡œ ëŠ˜ë ¤ì§€ì§€ë§Œ, ìƒí™˜ ì…ë ¥ ì‹œê°„ìœ¼ë¡œ ì¸í•´ O(1)
        - nê°œì˜ ì›ì†Œë¥¼ ì‚½ì…í•  ë•Œ ì†Œìš” ì‘ì—…ì€ O(n)
        - í‰ê· ì ìœ¼ë¡œ ê° ì‚½ì…ì€ O(1)

**â¤ï¸ StringBuilder**

: ê°€ë³€ í¬ê¸° ë°°ì—´ì„ ì´ìš©í•´ì„œ í•„ìš”í•œ ê²½ìš°ì—ë§Œ ë¬¸ìì—´ ë³µì‚¬
```java
String joinWords(String[] words) {
	StringBuilder sentence = new StringBuilder();
	for (String w : words) {
		sentence.append(w);
	}
	return sentence.toString();
}
```


<h3> ğŸ«§ ë²¡í„° êµ¬í˜„í•˜ê¸° </h3>

**â¡ï¸ size() - í•­ëª©ì˜ ê°œìˆ˜**

```java
public static void main(String[] args){
    ArrayList<Object> sizeTest = new ArrayList<Object>();
    System.out.println( sizeTest.size() );  // 0
}
```

**â¡ï¸ capacity() - ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ” í•­ëª©ì˜ ìµœëŒ€ ê°œìˆ˜**

```java
public static void main(String[] args) {
    StringBuffer buff = new StringBuffer(20);
    buff.append("GwangJik");
    System.out.println("Capacity : " + buff.capacity());    // 20
}
```

**â¡ï¸ is_empty()**

```java
String test = null;
if(test != null && test.isEmpty()) {
    System.out.println(test);
}
```

**â¡ï¸ at(index) - ì¸ë±ìŠ¤ì— ìˆëŠ” í•­ëª©ì„ ëŒë ¤ì£¼ê³ , ì¸ë±ìŠ¤ê°€ ë²”ìœ„ ë°–ì´ë©´ ì—ëŸ¬ë¥¼ ëƒ„**

```java
int digitStr = "456";

// 0ë²ˆì§¸ì— ìˆëŠ” char ê°’ì„ ë¦¬í„´
digitStr.charAt(0) // 4
```

**â¡ï¸ push(item)**

```java
var fruit = ["ì‚¬ê³¼", "ë°°", "í¬ë„"];
fruit.push("ë”¸ê¸°");      // ë°°ì—´ ë’¤ìª½ì— ë°ì´í„° ì‚½ì… ["ì‚¬ê³¼", "ë°°", "í¬ë„", "ë”¸ê¸°"]
```

**â¡ï¸ insert(index, item) - indexì— itemì„ ì‚½ì…í•˜ê³  ê¸°ì¡´ ì¸ë±ìŠ¤ì˜ ê°’ë¶€í„° ì­‰ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì‰¬í”„íŠ¸**

```java
public class ArrayListDemo {
    public static void main(String[] args)
    {
        // create an empty list with an initial
        // capacity
        List<String> list = new ArrayList<String>(5);
 
        // use add() method to initially
        // add elements in the list
        list.add("Geeks");
        list.add("For");
        list.add("Geeks");
       
        // Add a new element at index 0
        list.add(0, "Hello");
       
        // prints all the elements available in list
        for (String str : list) {
            System.out.print(str + " ");
        }
    }
}
// Hello Geeks For Geeks
```

**â¡ï¸ prepend(item) - ë§¨ ì•ì— ì›ì†Œë¥¼ ì‚½ì…**

```java
int[] arr = { 10, 20, 30 };

arr = ArrayUtils.add(arr, 40);
```

**â¡ï¸ pop() - ë§ˆì§€ë§‰ ì›ì†Œë¥¼ ì‚­ì œí•˜ê³  ê°’ì„ ëŒë ¤ì¤€ë‹¤**

```java
var fruit = ["ì‚¬ê³¼", "ë°°", "í¬ë„"];
fruit.pop();             // ë°°ì—´ ë’¤ìª½ì˜ ë°ì´í„° ì œê±° ["ì‚¬ê³¼", "ë°°"]
```

**â¡ï¸ delete(index) - delete item at index, shifting all trailing elements left**

```java
import java.io.File;  // Import the File class

public class DeleteFile {
  public static void main(String[] args) { 
    File myObj = new File("filename.txt"); 
    if (myObj.delete()) { 
      System.out.println("Deleted the file: " + myObj.getName());
    } else {
      System.out.println("Failed to delete the file.");
    } 
  } 
}

// Deleted the file: filename.txt
```

**â¡ï¸ remove(item) - looks for value and removes index holding it (even if in multiple places)**

```java
String[] fruitsArray = {"apple", "banana", "kiwi", "mango"};
ArrayList<String>  fruits = new ArrayList<>(Arrays.asList(fruitsArray));
System.out.println("all: " + fruits.toString());

String returned = fruits.remove(2);
System.out.println("remove(2): " + fruits.toString());
System.out.println("returned: " + returned);

// all: [apple, banana, kiwi, mango]
// remove(2): [apple, banana, mango]
// returned: kiwi
```

**â¡ï¸ find(item) - looks for value and returns first index with that value, -1 if not found**

```java
import java.util.regex.Matcher;  
import java.util.regex.Pattern;  
  
public class BooleanFindMethodExample1 {  
    public static void main(String[] args) {  
        // TODO Auto-generated method stub  
        Pattern p=Pattern.compile("java");  
        Matcher m=p.matcher("HellojavaHellojava");  
        int c=0;  
        // finding matching char   
        while(m.find())  
        {  
        c=c+1;  
        System.out.println("Start position of matching String "+m.start());  
        System.out.println("End position of Matching String (java) "+m.end());  
        }  
        System.out.println(" Number of matches : "+c);  
    }  
}
```

```java
Pattern pat = Pattern.compile("ì—¬ê¸°ì— ì •ê·œì‹ ì…ë ¥"); 
íŒ¨í„´ì„ ì •ì˜ í•œ í›„

Matcher match = pat.matcher("ì—¬ê¸°ì— ì¡°ì‚¬í•  ë¬¸ìì—´");
ì •ì˜ëœ íŒ¨í„´ì— ë§¤ì¹˜ ë˜ëŠ” ê°’ì„ ì €ì¥í•œë‹¤.

match.find()
ë§¤ì¹˜ëœ ê°’ì´ ìˆìœ¼ë©´ true ì—†ìœ¼ë©´ falseë¥¼ ë°˜í™˜í•œë‹¤.

match.group()
ë§¤ì¹˜ëœ ê°’ì„ ë°˜í™˜í•œë‹¤.
```

**â¡ï¸ resize(new_capacity) // private í•¨ìˆ˜**

- **ìš©ëŸ‰ì´ ê½‰ ì°¨ë©´, ê·¸ ë‘ë°°ë¡œ í¬ê¸°ë¥¼ ì¡°ì •í•œë‹¤.**
- **itemì„ í•˜ë‚˜ êº¼ë‚¼ ë•Œ, ìš©ëŸ‰ì´ 1/4ì´ë¼ë©´, ìš©ëŸ‰ì„ ì ˆë°˜ìœ¼ë¡œ ì¤„ì¸ë‹¤.**


<h3> ğŸ«§ ì—°ê²° ë¦¬ìŠ¤íŠ¸ </h3>

: ì°¨ë¡€ë¡œ ì—°ê²°ëœ ë…¸ë“œë¥¼ í‘œí˜„í•´ì£¼ëŠ” ìë£Œêµ¬ì¡°

: ë‹¨) ë°°ì—´ê³¼ ë‹¬ë¦¬ íŠ¹ì • ì¸ë±ìŠ¤ë¥¼ ìƒìˆ˜ ì‹œê°„ì— ì ‘ê·¼í•  ìˆ˜ ì—†ë‹¤

(kë²ˆì§¸ ì›ì†Œë¥¼ ì°¾ê³ ì‹¶ë‹¤ë©´ ì²˜ìŒë¶€í„° kë²ˆ ë£¨í”„ ëŒì•„ì•¼í•¨)

: ì¥) ë¦¬ìŠ¤íŠ¸ì˜ ì‹œì‘ ì§€ì ì—ì„œ ì•„ì´í…œì„ ì¶”ê°€í•˜ê±°ë‚˜ ì‚­ì œ ì—°ì‚°ì„ ìƒìˆ˜ ì‹œê°„ì— í•  ìˆ˜ ìˆë‹¤

- ë‹¨ë°©í–¥
    
    ![4.png](/assets/img/gani0325/4.png){: width="150" }

    - ê° ë…¸ë“œëŠ” ë‹¤ìŒ ë…¸ë“œ ê°€ë¦¬í‚´
- ì–‘ë°©í–¥
    
    ![5.png](/assets/img/gani0325/5.png){: width="150" }

    - ê° ë…¸ë“œëŠ” ë‹¤ìŒ ë…¸ë“œì™€ ì´ì „ ë…¸ë“œë¥¼ í•¨ê»˜ ê°€ë¦¬í‚´

**ğŸ’– (ë‹¨ë°©í–¥) ì—°ê²° ë¦¬ìŠ¤íŠ¸ ë§Œë“¤ê¸°**

```java
class Node {
	Node next = null;
	int data;
	public Node(int d) {
		data = d;
	}

	void appendToTail(int d) {
		Node end = new Node(d);
		Node n = this;
		while (n.next != null) {
			n = n.next;
		{
		n.next = end;
	}
}
```

**ğŸ’– (ë‹¨ë°©í–¥) ì—°ê²° ë¦¬ìŠ¤íŠ¸ ì‚­ì œ**

1) ë…¸ë“œ n ì´ ì£¼ì–´ì§€ë©´, ì´ì „ ë…¸ë“œ prev ë¥¼ ì°¾ì•„ [prev.next](http://prev.next) ì™€ [n.next](http://n.next) ê°€ ê°™ë„ë¡ ì„¤ì •í•œë‹¤

- ì–‘ë°©í–¥ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì¼ ê²½ìš°, n.nextê°€ ê°€ë¦¬í‚¤ëŠ” ë…¸ë“œë¥¼ ê°±ì‹ í•˜ì—¬ n.next.prev ê°€ n.prev ê°€ ê°™ë„ë¡ ì„¤ì •

> **ğŸ’¥ ì£¼ì˜**
- ë„ í¬ì¸íŠ¸ ê²€ì‚¬ë¥¼ ë°˜ë“œì‹œ í•œë‹¤
- headì™€ tail í¬ì¸í„°ë¥¼ ê°±ì‹ í•œë‹¤
> 

```java
Node deleteNode(Node head, int d) {
	Node n = head;
	if (n.data == d) {
		return head.next;    // head ì›€ì§ì´ê¸°
	}

	while (n.next != null) {
		if (n.next.data == d) {
			n.next = n.next.next;
			return head;     // head ì›€ì§ì´ì§€ ì•ŠìŒ
		}
	}
	return head;
}
	
```

**ğŸ’– Runner (ë¶€ê°€ í¬ì¸í„°)**

: ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¥¼ ìˆœíšŒí•  ë•Œ ë‘ ê°œì˜ í¬ì¸í„°ë¥¼ ë™ì‹œì— ì‚¬ìš©í•˜ëŠ” ê²ƒ

: í•œ í¬ì¸í„°ê°€ ë‹¤ë¥¸ í¬ì¸í„°ë³´ë‹¤ ì•ì„œë„ë¡ í•œë‹¤

- ì•ì„  í¬ì¸í„°ëŠ” ë’¤ í¬ì¸í„°ë³´ë‹¤ í•­ìƒ ì§€ì •ëœ ê°œìˆ˜ë§Œí¼ì€ ì•ì„¤ ìˆ˜ ìˆë‹¤
- ë’¤ í¬ì¸í„°ë¥¼ ì—¬ëŸ¬ ë…¸ë“œë¥¼ í•œë²ˆì— ë›°ì–´ë„˜ë„ë¡ ì„¤ì •í•  ìˆ˜ ìˆë‹¤

**ğŸ’– ì¬ê·€ ë¬¸ì œ**

: ì¬ê·€ í˜¸ì¶œ ê¹Šì´ê°€ nì¼ ê²½ìš°, í•´ë‹¹ ì¬ê·€ ì•Œê³ ë¦¬ì¦˜ì´ ì ì–´ë„ O(n) ì˜ ê³µê°„ì„ ì‚¬ìš©

<h2> ğŸ«§ ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ êµ¬í˜„í•˜ê¸° </h2>


**â¡ï¸** size() - ë¦¬ìŠ¤íŠ¸ ì•ˆì˜ ë°ì´í„° ê°œìˆ˜ë¥¼ ë°˜í™˜í•œë‹¤.

```java
LinkedList<Integer> list = new LinkedList<Integer>(Arrays.asList(1,2,3));
System.out.println(list.size()); //list í¬ê¸° : 3
```

**â¡ï¸** empty() - ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì–´ìˆë‹¤ë©´ trueë¥¼ ë°˜í™˜í•œë‹¤.

```java
// ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì—ˆëŠ”ê°€
template <typename E>
bool SLinkedList<E>::empty() const{
    return head == NULL;
}
```

**â¡ï¸** value_at(index) - indexë²ˆì§¸ ìœ„ì¹˜ì˜ valueì„ ë°˜í™˜í•œë‹¤. (ê°€ì¥ ì•ì€ 0ë¶€í„° ì‹œì‘í•œë‹¤.)

```cpp
# declaring array
a = [18, 22, 33, nil, 5, 6]

puts "values_at() method form : #{a.values_at(2, 4)}\n\n"
// values_at() method form : [33, 5]
```

**â¡ï¸** push_front(value) - ê°€ì¥ ì•ì— valueë¥¼ ì¶”ê°€í•œë‹¤.

```cpp
int main(void) {
	list<int> L = { 3, 7 };
	L.push_front(1); // { 1, 3, 7 }
	return 0;
}
```

**â¡ï¸** pop_front() - ê°€ì¥ ì•ì— ìˆëŠ” ê²ƒì„ ì œê±°í•˜ê³ , ê·¸ valueë¥¼ ë°˜í™˜í•œë‹¤.

```cpp
int main(void) {
	list<int> L = { 1, 5, 3, 7, 10 }   
	L.pop_front(); // { 5, 3, 7, 10 }
	return 0;
}
```

**â¡ï¸** push_back(value) - ê°€ì¥ ëì— valueì„ ì¶”ê°€í•œë‹¤.

```cpp
int main(void) {
	list<int> L = { 3, 7 };
	L.push_back(10); // { 3, 7, 10 }
	return 0;
}
```

**â¡ï¸** pop_back() - ê°€ì¥ ëì— ìˆëŠ” ê²ƒì„ ì œê±°í•˜ê³ , ê·¸ valueë¥¼ ë°˜í™˜í•œë‹¤.

```cpp
int main(void) {
	list<int> L = { 1, 5, 3, 7, 10 }   
	L.pop_back(); // { 5, 3, 7, 10}
	return 0;
}
```

**â¡ï¸** front() - ê°€ì¥ ì•ì— ìˆëŠ” ê²ƒì˜ valueë¥¼ ê°€ì ¸ì˜¨ë‹¤.

```cpp
class CircleList{
public:
    CircleList(); // ìƒì„±ì
    ~CircleList(); // ì†Œë©¸ì

    const string& front() const; // ì»¤ì„œ ë‹¤ìŒì˜ ì›ì†Œ
};
```

**â¡ï¸** back() - ê°€ì¥ ëì— ìˆëŠ” ê²ƒì˜ valueë¥¼ ê°€ì ¸ì˜¨ë‹¤.

```cpp
class CircleList{
public:
    CircleList(); // ìƒì„±ì
    ~CircleList(); // ì†Œë©¸ì

    const string& back() const; // ì»¤ì„œì˜ ì›ì†Œ

};
```

**â¡ï¸** insert(index, value) - indexë²ˆì§¸ ìœ„ì¹˜ì— valueë¥¼ ì¶”ê°€í•œë‹¤. ì¦‰, indexë²ˆì§¸ì— ìƒˆë¡œ ì¶”ê°€ëœ ê²ƒì´ ê¸°ì¡´ì˜ indexë²ˆì§¸ì— ìˆë˜ ê²ƒì„ ê°€ë¦¬í‚¨ë‹¤.

```cpp
list<int>::iterator iterInsertPos = list1.begin();
list1.insert(iterInsertsPos, 100);    // ì²« ë²ˆì§¸ ìœ„ì¹˜ì— 100 ë„£ê¸°
```

**â¡ï¸** erase(index) - indexë²ˆì§¸ì— ìˆëŠ” ë…¸ë“œë¥¼ ì‚­ì œí•œë‹¤.

```cpp
list1.erase(list1.begin());    // list1 ì²« ë²ˆ ì§¸ ìš”ì†Œ ì‚­ì œ
```

**â¡ï¸** value_n_from_end(n) - ë’¤ì—ì„œë¶€í„° në²ˆì§¸ì— ìˆëŠ” ë…¸ë“œì˜ valueë¥¼ ë°˜í™˜í•œë‹¤.

**â¡ï¸** reverse() - ë¦¬ìŠ¤íŠ¸ë¥¼ ë’¤ì§‘ëŠ”ë‹¤.

```cpp
public class UnitTest {
    public static void main(String[] args) {
        SinglyLinkedList list = new SinglyLinkedList();
        list.addLast(1);
        list.addLast(2);
        list.addLast(3);
        list.addLast(4);

        System.out.println(list);
        list.reverse();

        System.out.println(list);
    }
}

// 1 -> 2 -> 3 -> 4
// 4 -> 3 -> 2 -> 1
```

**â¡ï¸** remove_value(value) - valueì™€ ê°™ì€ ê°’ì„ ê°€ì§€ëŠ” ì²« ë²ˆì§¸ ë…¸ë“œë¥¼ ì œê±°í•œë‹¤.

<h2> ğŸ«§ ìŠ¤íƒ </h2>

: ë°ì´í„°ë¥¼ ìŒ“ì•„ ì˜¬ë¦°ë‹¤

: LIFO (Last In First Out) ì— ë”°ë¼ ìë£Œë¥¼ ë°°ì—´í•œë‹¤

: ê°€ì¥ ìµœê·¼ì— ìŠ¤íƒì— ì¶”ê°€í•œ í•­ëª©ì´ ê°€ì¥ ë¨¼ì € ì œê±°ë  í•­ëª©

: ë°°ì—´ê³¼ ë‹¬ë¦¬ ìŠ¤íƒì€ ìƒìˆ˜ ì‹œê°„ì— i ë²ˆì§¸ í•­ëª©ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŒ

: ìŠ¤íƒì—ì„œ ë°ì´í„°ë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ì‚­ì œí•˜ëŠ” ì—°ì‚°ì€ ìƒìˆ˜ ì‹œê°„ì— ê°€ëŠ¥í•˜ë‹¤


<h2> ğŸ«§ ìŠ¤íƒì´ ìœ ìš©í•  ê²½ìš° </h2>

: ì¬ê·€ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•  ë•Œ ìœ ìš©í•¨

: ì¬ê·€ì ìœ¼ë¡œ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì•¼ í•˜ëŠ” ê²½ìš°ì— ì„ì‹œ ë°ì´í„°ë¥¼ ìŠ¤íƒì— ë„£ì–´ ì£¼ê³ , ì¬ê·€ í•¨ìˆ˜ë¥¼ ë¹ ì ¸ ë‚˜ì™€ í‡´ê° ê²€ìƒ‰(backtrack) í•  ë•ŒëŠ” ìŠ¤íƒì— ë„£ì–´ ì£¼ì—ˆë˜ ì„ì‹œ ë°ì´í„°ë¥¼ ë¹¼ ì¤˜ì•¼ í•œë‹¤

: ì¼ë ¨ì˜ í–‰ìœ„ë¥¼ ì§ê´€ì ìœ¼ë¡œ ê°€ëŠ¥í•˜ê²Œ í•´ ì¤€ë‹¤

: ì¬ê·€ ì•Œê³ ë¦¬ì¦˜ì„ ë°˜ë³µì  í˜•íƒœ (iterative) ë¥¼ í†µí•´ì„œ êµ¬í˜„í•  ìˆ˜ ìˆê²Œ í•¨

<h2> ğŸ«§ ìŠ¤íƒ êµ¬í˜„í•˜ê¸° </h2>

```java
function Stack(arr = Array()) {
  this.arr = arr;
}

let stk = new Stack();
let stk2 = new Stack(['test', 'test2']);
```

â¡ï¸ isEmpty() : ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸(ë°˜í™˜ê°’ t/f)

```java
Stack.prototype.isEmpty = function(){
  return this.arr.length === 0;
}
```

â¡ï¸ push(data) : ìŠ¤íƒì— ë°ì´í„° ì¶”ê°€í•˜ê¸°

```java
Stack.prototype.push = function (data) {
  this.arr.push(data);
};
```

â¡ï¸ pop() : ìŠ¤íƒ ë§¨ ìœ„ì˜ ë°ì´í„° ì‚­ì œí•˜ê¸°

```java
Stack.prototype.pop = function () {
  return this.arr.pop();
};
```

â¡ï¸ top() : ìŠ¤íƒ ë§¨ ìœ„ì˜ ë°ì´í„° í™•ì¸í•˜ê¸°

```java
Stack.prototype.top = function () {
  return this.arr.slice(-1);
};
```

â¡ï¸ size() : ìŠ¤íƒì˜ ë°ì´í„° ê°œìˆ˜ ì¶œë ¥

```java
Stack.prototype.size = function () {
  return this.arr.length;
};
```

<h2> ğŸ«§ í </h2>

: FIFO (First In First Out) ìˆœì„œ

: íì— ì €ì¥ë˜ëŠ” í•­ëª©ë“¤ì€ íì— ì¶”ê°€ë˜ëŠ” ìˆœì„œëŒ€ë¡œ ì œê±°ëœë‹¤

- ë„ˆë¹„ ìš°ì„  íƒìƒ‰ (bfs)
    - ì²˜ë¦¬í•´ì•¼ í•  ë…¸ë“œì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ì €ì¥í•˜ëŠ” ìš©ë„ë¡œ í ì‚¬ìš©
    - ë…¸ë“œë¥¼ í•˜ë‚˜ ì²˜ë¦¬í•  ë•Œë§ˆë‹¤ í•´ë‹¹ ë…¸ë“œì™€ ì¸ì ‘í•œ ë…¸ë“œë“¤ì„ íì— ë‹¤ì‹œ ì €ì¥
    - ë…¸ë“œë¥¼ ì ‘ê·¼í•œ ìˆœì„œëŒ€ë¡œ ì²˜ë¦¬ ê°€ëŠ¥
- ìºì‹œ êµ¬í˜„

<h2> ğŸ«§ í êµ¬í˜„í•˜ê¸° </h2>

**ğŸ’– tail í¬ì¸í„°ê°€ ìˆëŠ” ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„í•˜ê¸°**

**â¡ï¸ enqueue(value)** - tailì´ ê°€ë¦¬í‚¤ëŠ” ê³³ì— valueë¥¼ ì¶”ê°€í•œë‹¤

```cpp
int main()
{
    int keys[] = { 1, 2, 3, 4, 5 };
    Queue q;
 
    // ìœ„ì˜ í‚¤ ì‚½ì…
    for (int key: keys) {
        q.enqueue(key);
    }
    return 0;
}
```

**â¡ï¸** dequeue() - valueë¥¼ ë°˜í™˜í•˜ê³  ê°€ì¥ ìµœê·¼ì— ì¶”ê°€ëœ ì›ì†Œ(front)ë¥¼ ì œê±°í•œë‹¤.

```cpp
int main()
{
    int keys[] = { 1, 2, 3, 4, 5 };
    Queue q;
 
    // ìœ„ì˜ í‚¤ ì‚½ì…
    for (int key: keys) {
        q.enqueue(key);
    }
 
    cout << q.dequeue() << endl;    // 1ì„ ì¶œë ¥
    cout << q.dequeue() << endl;    // 2ë¥¼ ì¶œë ¥
 
    return 0;
}
```

**â¡ï¸** empty()

```cpp
#include <iostream>
#include <stack>
#include <cstdlib>
using namespace std;
 
// ë‘ ê°œì˜ Stackì„ ì‚¬ìš©í•˜ì—¬ Queue êµ¬í˜„
class Queue
{
    stack<int> s1, s2;
 
public:
    // Queueì— ì•„ì´í…œ ì¶”ê°€
    void enqueue(int data)
    {
        // ì²« ë²ˆì§¸ Stackì˜ ëª¨ë“  ìš”ì†Œë¥¼ ë‘ ë²ˆì§¸ Stackìœ¼ë¡œ ì´ë™
        while (!s1.empty())
        {
            s2.push(s1.top());
            s1.pop();
        }
 
        // í•­ëª©ì„ ì²« ë²ˆì§¸ Stackì— í‘¸ì‹œ
        s1.push(data);
 
        // ëª¨ë“  ìš”ì†Œë¥¼ ë‘ ë²ˆì§¸ Stackì—ì„œ ì²« ë²ˆì§¸ Stackìœ¼ë¡œ ë‹¤ì‹œ ì´ë™í•©ë‹ˆë‹¤.
        while (!s2.empty())
        {
            s1.push(s2.top());
            s2.pop();
        }
    }
 
    // Queueì—ì„œ ì•„ì´í…œ ì œê±°
    int dequeue()
    {
        // ì²« ë²ˆì§¸ Stackì´ ë¹„ì–´ ìˆëŠ” ê²½ìš°
        if (s1.empty())
        {
            cout << "Underflow!!";
            exit(0);
        }
 
        // ì²« ë²ˆì§¸ Stackì˜ ìµœìƒìœ„ í•­ëª©ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
        int top = s1.top();
        s1.pop();
        return top;
    }
};
```

**ğŸ§¡ ê³ ì • ê¸¸ì´ ë°°ì—´ì„ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„í•˜ê¸°**

- enqueue(value) - ì‚¬ìš© ê°€ëŠ¥í•œ ì €ì¥ ê³µê°„ì˜ ëì— itemì„ ì¶”ê°€í•œë‹¤.
- dequeue() - valueë¥¼ ë°˜í™˜í•˜ê³  ê°€ì¥ ìµœê·¼ì— ì¶”ê°€ëœ ì›ì†Œë¥¼ ì œê±°í•œë‹¤.
- empty()
- full()

**ğŸ’› ë¹„ìš©**

- a bad implementation using linked list where you enqueue at head and dequeue at tail would be O(n) because you'd need the next to last element, causing a full traversal each dequeue
- enqueue: O(1) (amortized, linked list and array [probing])
- dequeue: O(1) (linked list and array)
- empty: O(1) (linked list and array)

<h2> ğŸ«§ í•´ì‹œí…Œì´ë¸” (hash table) </h2>

: íš¨ìœ¨ì ì¸ íƒìƒ‰ì„ ìœ„í•œ ìë£Œêµ¬ì¡°ë¡œì„œ, keyë¥¼ value ì— ëŒ€ì‘ì‹œí‚´

: ìµœì•…ì˜ ê²½ìš° O(n)      // nì€ í‚¤ì˜ ê°œìˆ˜

: ìµœì„ ì˜ ê²½ìš° O(1)

<h2> ğŸ«§ ì—°ê²°ë¦¬ìŠ¤íŠ¸ì™€ í•´ì‹œ ì½”ë“œ í•¨ìˆ˜ë¡œ êµ¬í˜„ </h2>

**1) í‚¤ì˜ í•´ì‹œ ì½”ë“œ ê³„ì‚°**

- í‚¤ì˜ ìë£Œí˜•ì€ ë³´í†µ int or long
- í‚¤ì˜ ê°œìˆ˜ ë¬´í•œ (int ëŠ” ìœ í•œ)

**2) hash(key) % array_length ë°©ì‹ìœ¼ë¡œ í•´ì‹œ ì½”ë“œ ì´ìš©í•´ ë°°ì—´ì˜ ì¸ë±ìŠ¤ êµ¬í•¨**

- ì„œë¡œ ë‹¤ë¥¸ ë‘ ê°œì˜ í•´ì‹œ ì½”ë“œê°€ ê°™ì€ ì¸ë±ìŠ¤ ê°€ë¦¬í‚¬ ìˆ˜ ìˆìŒ

**3) ë°°ì—´ì˜ ê° ì¸ë±ìŠ¤ì—ëŠ” í‚¤ì™€ ê°’ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ì—°ê²°ë¦¬ìŠ¤íŠ¸ ì¡´ì¬**

- í‚¤ì™€ ê°’ì„ í•´ë‹¹ ì¸ë±ìŠ¤ì— ì €ì¥ (ë°˜ë“œì‹œ ì—°ê²°ë¦¬ìŠ¤íŠ¸ ì´ìš©!)
- **ğŸ’¥ ì¶©ëŒ** : ì„œë¡œ ë‹¤ë¥¸ ë‘ ê°œì˜ í‚¤ê°€ ê°™ì€ ì½”ë“œë¥¼ ê°€ë¦¬í‚¤ê±°ë‚˜, ì„œë¡œ ë‹¤ë¥¸ ë‘ ê°œì˜ í•´ì‹œ ì½”ë“œê°€ ê°™ì€ ì¸ë±ìŠ¤ë¥¼ ê°€ë¦¬í‚¤ëŠ” ê²½ìš°

â‡’ í‚¤ì— ìƒì‘í•˜ê¸° ìœ„í•´ì„œ ìœ„ë¥¼ ë°˜ë³µ!

â‡’ ì£¼ì–´ì§„ í‚¤ë¡œë¶€í„° í•´ì‹œ ì½”ë“œë¥¼ ê³„ì‚°, í•´ì‹œ ì½”ë“œë¥¼ ì´ìš©í•´ ì¸ë±ìŠ¤ ê³„ì‚°, í•´ë‹¹ í‚¤ì— ìƒì‘í•˜ëŠ” ê°’ì„ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì—ì„œ íƒìƒ‰

> **ê· í˜• ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ (balanced binary search tree)** 
: íƒìƒ‰ ì‹œê°„ì€ O(logN)
: í¬ê¸°ê°€ í° ë°°ì—´ì„ ë¯¸ë¦¬ í• ë‹¹í•´ ë†“ì§€ ì•Šì•„ë„ ë˜ê¸° ë•Œë¬¸ì— ì ì€ ê³µê°„ ì‚¬ìš© ê°€ëŠ¥

: í‚¤ì˜ ì§‘í•©ì„ íŠ¹ì • ìˆœì„œëŒ€ë¡œ ì ‘ê·¼ ê°€ëŠ¥
> 

<h2> ğŸ«§ í•´ì‹œí…Œì´ë¸” êµ¬í˜„í•˜ê¸° </h2>

Linear probingì„ ì‚¬ìš©í•˜ì—¬ ë°°ì—´ë¡œ êµ¬í˜„í•´ë³´ê¸°

```java
class Node:
    def __init__(self, key, value, next):
        self.key = key
        self.value = value
        self.next = next
```

**â¡ï¸ hash(k, m) - mì€ í•´ì‹œ í…Œì´ë¸”ì˜ í¬ê¸°**

```jsx
// mapì˜ í¬ê¸°: map.size()
map.size // 4
map.length // undefined
```

**â¡ï¸ add(key, value) - í‚¤ê°€ ì´ë¯¸ ì¡´ì¬í•œë‹¤ë©´, ê°’ì„ ê°±ì‹ í•œë‹¤.**

```java
Hashtable ht = new Hashtable();
ht.Add("irina", "Irina SP");
ht.Add("tom", "Tom Cr");

if (ht.Contains("tom"))
{
    Console.WriteLine(ht["tom"]);
}
```

**â¡ï¸ exists(key)**

```jsx
mapì— í•´ë‹¹ keyì˜ value ì¡´ì¬ ì—¬ë¶€: has(key)
map.has(str); // true
map.has(obj); // true
map.has('none'); // falsemapì˜ í¬ê¸°: map.size()
map.size // 4
map.length // undefinedmapì˜ í¬ê¸°: map.size()
map.size // 4
map.length // undefined
```

**â¡ï¸ get(key)**

- Map ê°ì²´ëŠ” key-valueë¡œ ì´ë£¨ì–´ì§„ í•´ì‹œí…Œì´ë¸”
    - set(): key-value pairë¥¼ mapì— ì‚½ì…
    - get(): keyê°’ìœ¼ë¡œ valueë¥¼ ì°¾ì•„ ë¦¬í„´
    - keyì— ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ” ìë£Œí˜•ì€ number, string, function, object, NaN ë“±ì´ ê°€ëŠ¥
    
    ```jsx
    let number = 0;
    let str = 'string';
    let obj = { a: 1 };
    let func = () => {
        console.log('func');
    };
    
    map.set(number, 4); //keyì— number ê°€ëŠ¥
    map.set(str, 1); // keyì— string ê°€ëŠ¥
    map.set(obj, 2); //keyì— object ê°€ëŠ¥
    map.set(func, 3); // keyì— í•¨ìˆ˜ ê°€ëŠ¥
    map.set(number, 0); // ë®ì–´ì“°ê¸° ê°€ëŠ¥
    
    console.log(map); // Map(4) {0 => 0, "string" => 1, {â€¦} => 2, Æ’unc => 3}
    
    map.get(str); // 1
    map.get(obj); // 2
    map.get('none'); // undefined  
    map.get({ a: 1 }); // undefined, obj !== { a: 1 }
    ```
    

**â¡ï¸ remove(key)**

```csharp
using System;
using System.Collections;
public class SamplesHashtable
{

   public static void Main()
   {
      // Creates and initializes a new Hashtable.
      var myHT = new Hashtable();
      myHT.Add("1a", "The");
      myHT.Add("1b", "quick");

      // Removes the element with the key "3b".
      myHT.Remove("3b");

   }
}
```