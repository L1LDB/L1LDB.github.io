---
title: 🐢 8. Thread & Lock
author: gani0325
date: 2023-12-17 20:00:00 +09:00
categories: [코딩 인터뷰 대학, 8. Thread & Lock]
tags: [코딩 인터뷰 대학, 추가 지식, 9주차, 이가은]
render_with_liquid: false
math: true
---

<h3> 🫧 동기화와 락 </h3>
  - 어떤 프로세스 안에서 생성된 스레드들은 같은 메모리 공간을 공유함
  - 스레드가 서로 데이터를 공유할 수 있음
  - 두 스레드가 같은 자원을 동시에 변경하는 경우는 문제가 된다
- synchronized
  - 공유 자원에 대한 접근을 제어함
- 락
  - 세밀하게 동기화를 제어함
  - 락을 공유 자원에 붙이면 해당 자원에 대한 접근을 동기화 할 수 있다
  - 스레드가 해당 자원을 접근하려면 우선 그 자원에 붙어 있는 락을 획득 해야 함
  - 특정 시점에 락을 쥐고 있을 수 있는 스레드는 하나 뿐
  - 해당 공유 자원은 한 번에 한 스레드만 사용이 가능
- 교착상태와 교착상태 방지
  - 첫 번째 스레드는 두 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리고 있고, 두 번째 스레드 역시 첫 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리는 상황
  - 모든 스레드가 락이 풀리기를 기다리고 있기 때문에, 무한 대기 상태에 빠지게 됨
    - 상호 배체 (Mutual exclusion) : 한 번에 한 프로세스만 공유 자원을 사용할 수 있다
    - 들고 기다리기 (Hold and wait) : 공유 자원에 대한 접근 권한을 갖고 있는 프로세스가, 그 접근 권한을 양보하지 않은 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있다
    - 선취 (Preemption) 불가능 : 한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 없다
    - 대기 상태의 사이클 (Circular wait) : 두 개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재한다

---

<h3> 🫧 C언어와 C++ </h3>

- 클래스와 상속
  - C++ 에서 모든 데이터 멤버와 메서드는 기본적으로 private
- 생성자와 소멸자
  - 생성자는 객체가 생성되면 자동으로 호출된다
  - 생성자가 정의되어 있지 않으면 컴파일러는 기본 생성자라고 불리는 생성자를 자동으로 만든다
  ```jsx
  Person ( int a : id(a) {
  ...
  }
  ```
  - 데이터 멤버의 id 는 실제 객체가 만들어지기 전, 생성자 코드의 나머지 부분이 실행되기 전에 값을 할당받는다
  - 소멸자는 객체가 소멸될 때 자동으로 호출되며, 객체를 삭제하는 작업을 담당한다
    - 명시적으로 호출할 수 있는 메서드가 아니므로, 인자를 전달할 수 없다
    ```jsx
    ~Person() {
    	delete obj;
    }
    ```
- 가상 함수

  - 부모 클래스에 어떤 메서드를 구현해 둘 수 없는 경우에도 가상 함수를 사용한다
  - 순수 가상 함수로 선언하여 그 구현은 하위 클래스들에게 맡겨야 한다
  - addCourse 를 순수 가상 함수로 선언하였으므로, Person 클래스는 스스로 객체를 만들어 낼 수 없는 추상 클래스가 된다

  ```jsx
  class Person {
  	int id;
  	char name[Name_size];
  public:
  	virtual void aboutMe() {
  		cout << "I am a person" << endl;
  	}
  	virtual bool addCourse(string s) = 0;
  };

  class Student : public Person {
  public:
  	void aboutMe() {
  		cout << "I am a Student|"" << endl;
  	}
  	bool addCourse(string s) {
  		cout << "Added course" << s << " to student " << endl;
  		return true;
  		}
  };

  int main() {
  	Person *p = new Student();
  	p -> aboutMe();
  	p -> addCourse("History");
  	delete p;
  }
  ```

- 가상 소멸자
  - 가상 함수의 개념에서부터 자연스럽게 유도할 수 있다
- 기본값
  - 함수를 선언할 떼 기본값을 명시할 수 있다
  - 기본값은 반드시 함수 선언의 우측 부분에 놓여야 한다
  ```jsx
  int func(int a, int b = 3) {
  	x = a;
  	b = b;
  	return a * b;
  }
  ```
- 연산자 오버로딩
  - 연산자를 객체간 연산에도 사용할 수 있다
- 포인터와 참조
  - 포인터는 변수의 주소를 담는 변수
  - 변수의 값을 읽거나 변경하는 등 변수에 적용 가능한 연산은 모두 포인터를 통해 할 수 있다
  - 두 포인터가 같은 주소를 가리키는 경우에 한 포인터가 가리키는 변수의 값을 변경하면 다른 포인터가 가리키는 변수의 값도 바뀐다
- 참조
  - 별도의 메모리를 갖지 않는다-
  - 참조는 null 이 될 수 없으며, 다른 메모리에 재할당 될 수도 없다
- 포인터 연산
  - p++ 를 실행하면 p는 size(int) 바이트
- 템플릿
  - 하나의 클래스를 서로 다른 여러 타입에 재사용할 수 있도록 함
  - 여러 타입의 객체를 저장할 수 있는 연결리스트와 같은 자료구조를 만들 수 있다
